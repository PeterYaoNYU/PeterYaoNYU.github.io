<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>[Compiler Construction] Control Flow Graph, Liveness Analysis, Dataflow Analysis and Interference Graph, Implemented in OCaml - Peter Yuncheng Yao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Peter&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Peter&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="I am super busy, but I want to spend some time talking about how to write a compiler in ocaml that has liveness analysis, and can generate interference graph from CFG and liveness analysis, which is f"><meta property="og:type" content="blog"><meta property="og:title" content="[Compiler Construction] Control Flow Graph, Liveness Analysis, Dataflow Analysis and Interference Graph, Implemented in OCaml"><meta property="og:url" content="http://peteryaonyu.github.io/2024/04/17/Compiler-Construction-Control-Flow-Graph-Liveness-Analysis-Dataflow-Analysis-and-Interference-Graph-Implemented-in-OCaml/"><meta property="og:site_name" content="Peter Yuncheng Yao"><meta property="og:description" content="I am super busy, but I want to spend some time talking about how to write a compiler in ocaml that has liveness analysis, and can generate interference graph from CFG and liveness analysis, which is f"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://avatars.githubusercontent.com/u/93311390?v=4"><meta property="og:image" content="http://peteryaonyu.github.io/images/liveness_analyze.png"><meta property="article:published_time" content="2024-04-17T23:53:06.000Z"><meta property="article:modified_time" content="2024-04-18T03:42:39.443Z"><meta property="article:author" content="Yuncheng Yao"><meta property="article:tag" content="Compiler"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://avatars.githubusercontent.com/u/93311390?v=4"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://peteryaonyu.github.io/2024/04/17/Compiler-Construction-Control-Flow-Graph-Liveness-Analysis-Dataflow-Analysis-and-Interference-Graph-Implemented-in-OCaml/"},"headline":"[Compiler Construction] Control Flow Graph, Liveness Analysis, Dataflow Analysis and Interference Graph, Implemented in OCaml","image":["http://peteryaonyu.github.io/images/liveness_analyze.png"],"datePublished":"2024-04-17T23:53:06.000Z","dateModified":"2024-04-18T03:42:39.443Z","author":{"@type":"Person","name":"Yuncheng Yao"},"publisher":{"@type":"Organization","name":"Peter Yuncheng Yao","logo":{"@type":"ImageObject","url":{"text":"Yao Yuncheng(Peter)"}}},"description":"I am super busy, but I want to spend some time talking about how to write a compiler in ocaml that has liveness analysis, and can generate interference graph from CFG and liveness analysis, which is f"}</script><link rel="canonical" href="http://peteryaonyu.github.io/2024/04/17/Compiler-Construction-Control-Flow-Graph-Liveness-Analysis-Dataflow-Analysis-and-Interference-Graph-Implemented-in-OCaml/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Peter Yuncheng Yao" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Yao Yuncheng(Peter)</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/CV">CV</a><a class="navbar-item" href="/publication">Publication</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PeterYaoNYU"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-04-17T23:53:06.000Z" title="4/17/2024, 7:53:06 PM">2024-04-17</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-04-18T03:42:39.443Z" title="4/17/2024, 11:42:39 PM">2024-04-17</time></span><span class="level-item">19 minutes read (About 2891 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">[Compiler Construction] Control Flow Graph, Liveness Analysis, Dataflow Analysis and Interference Graph, Implemented in OCaml</h1><div class="content"><p>I am super busy, but I want to spend some time talking about how to write a compiler in ocaml that has liveness analysis, and can generate interference graph from CFG and liveness analysis, which is fundamental to doing correct, if not efficient, register allocation. </p>
<style>
                /* css part */
                .gr-card {

                    --gr-header-width-proportion: 10%;
                    --gr-footer-width-proportion: 10%;
                    --gr-content-width-proportion: 80%;

                    --gr-header-min-width: 80px;
                    --gr-footer-min-width: 80px;

                    --gr-card-element-margin: 6px 10px 6px 10px; /* header content footer*/

                    display: flex;
                    background-color: #fff;
                    border-radius: 6px;
                    overflow: hidden;
                    box-shadow: 0px 4px 6px rgba(0, 0, 0, .12);
                    margin-bottom: 20px;
                    vertical-align: middle;
                    position: relative;
                }

                .gr-header {
                    width: var(--gr-header-width-proportion);
                    min-width: var(--gr-header-min-width);
                    margin: var(--gr-card-element-margin);
                    background-color: #fff;
                    /* background-color: blueviolet; */
                }

                .gr-header img {
                    width: 80px;
                    height: 80px;
                    position: relative;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%,-50%);
                    object-fit: cover;
                    border-radius: 50%;
                    margin: 0px;
                }

                .gr-content {
                    width: var(--gr-content-width-proportion);
                    margin: var(--gr-card-element-margin);
                    background-color: #fff;
                    text-align: left;
                }

                #gr-github-icon {
                    font-size: 1.3rem;
                }
                .gr-fullname {
                    display: -webkit-box;
                    -webkit-box-orient: vertical;
                    -webkit-line-clamp: 1;
                    overflow: hidden;
                }

                .gr-fullname p {
                    line-height: 2rem;
                    margin: 10px 0px 0px 0px;
                    padding: 0;
                    font-size: .83rem;
                    font-weight: bolder;
                }

                .gr-description {
                    font-size: .8rem;
                    line-height: 1.6rem;
                    display: -webkit-box;
                    -webkit-box-orient: vertical;
                    -webkit-line-clamp: 1;
                    overflow: hidden;
                }

                .gr-footer {
                    width: var(--gr-footer-width-proportion);
                    min-width: var(--gr-footer-min-width);
                    margin: var(--gr-card-element-margin);
                    display: flex;
                    /* background-color: aqua; */
                    background-color: #fff;
                    position: relative;
                    padding: 0px;
                }

                .gr-language-star {
                    margin: auto auto 22px auto;
                    text-align: center;
                    opacity: 1;
                }

                .gr-language {
                    font-size: .8rem;
                    font-weight: 600;
                    line-height: 2.2rem;
                    color: #2070d3;
                }

                #gr-star-icon {
                    font-size: .8rem;
                    display: inherit;
                }

                .gr-card-toolbar{
                    display:flex;
                    width: 100%;
                    height: 100%;

                    position: absolute;

                    opacity: 0;
                    animation: fade-out;
                    animation-duration: .4s;
                    z-index: -1;
                    /* background-color: #2070d3; */
                }

                .gr-repo-link {
                    margin: auto;
                }

                #gr-repo-link-icon {
                    font-size: 16px;
                }
                /* animation part */

                @keyframes fade-in {
                    0% {opacity: 0;}/*初始状态 透明度为0*/
                    100% {opacity: 1;}/*结束状态 透明度为1*/
                }

                @keyframes fade-out {
                    0% {opacity: 1;}/*初始状态 透明度为0*/
                    100% {opacity: 0;}/*结束状态 透明度为1*/
                }

                .gr-card:hover .gr-language-star{
                    opacity: 0;
                    animation: fade-out;
                    animation-duration: .3s;
                }

                .gr-card:hover .gr-card-toolbar{
                    opacity: 1;
                    animation: fade-in;
                    animation-duration: .6s;
                    z-index: 1;
                }
                </style>

                <div class="gr-card">
                    <div class="gr-header">
                        <img src="https://avatars.githubusercontent.com/u/93311390?v=4" alt="">
                    </div>
                    <div class="gr-content">
                        <div class="gr-fullname">
                            <p><i class="fab fa-github fa-lg" aria-hidden="true" id="gr-github-icon"></i> PeterYaoNYU/CompilerInOCaml</p>
                        </div>
                        <div class="gr-description">
                            A compiler for a ML-ish Languange, with a ML->Scheme->C->CFG->MIPS Pipeline, Register Allocation and Garbage Collection.
                        </div>
                    </div>
                    <div class="gr-footer">
                        <div class="gr-language-star">
                            <span class="gr-language">OCaml</span>
                            <i class="far fa-star" aria-hidden="true" id='gr-star-icon'> 0</i>
                        </div>
                        <div class="gr-card-toolbar">
                            <div class="gr-repo-link">
                                <a href="https://github.com/PeterYaoNYU/CompilerInOCaml" target="_blank" rel="noopener noreferrer"
                                    title="Open in a new TAB">
                                    <i class="fas fa-external-link-square-alt fa-lg" aria-hidden="true" style="color: black;" id="gr-repo-link-icon"></i>
                                </a>
                            </div>
                        </div>
                    </div>
                </div>

<p>The Code can be found under the folder ps7, if not restructured after the writing of this post. </p>
<p>This is part of the NYU graduate level capstone project, with Prof. Joseph Tassarotti. </p>
<span id="more"></span>
<p>An interference graph is a prerequisite for building correct register allocation in a compiler. An interference graph relies on correct liveness analysis, and liveness is dependent on control flow graph, or cfg. CFG is a directed graph between blocks of code. The granularity of the block is adjustable, but to build efficient compiler that converges fast enough, one common optimization is to collapse codes together, with the last line of code in the cfg block being jump, return or if. </p>
<h2 id="CFG-AST"><a href="#CFG-AST" class="headerlink" title="CFG AST"></a>CFG AST</h2><p>We have an ast very similar to assembly, but has an infinite number of registers to store temporaries. </p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> operand = <span class="type">Int</span> <span class="keyword">of</span> <span class="built_in">int</span> | <span class="type">Var</span> <span class="keyword">of</span> var | <span class="type">Lab</span> <span class="keyword">of</span> label | <span class="type">Reg</span> <span class="keyword">of</span> <span class="type">Mips</span>.reg</span><br><span class="line"><span class="keyword">let</span> sp = <span class="type">Reg</span>(<span class="type">Mips</span>.<span class="type">R29</span>)</span><br><span class="line"><span class="keyword">let</span> fp = <span class="type">Reg</span>(<span class="type">Mips</span>.<span class="type">R30</span>)</span><br><span class="line"><span class="keyword">let</span> ra = <span class="type">Reg</span>(<span class="type">Mips</span>.<span class="type">R31</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> compareop = <span class="type">Eq</span> | <span class="type">Neq</span> | <span class="type">Lt</span> | <span class="type">Lte</span> | <span class="type">Gt</span> | <span class="type">Gte</span></span><br><span class="line"><span class="keyword">type</span> arithop = <span class="type">Plus</span> | <span class="type">Minus</span> | <span class="type">Times</span> | <span class="type">Div</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">(* essentially, a subset of the MIPS instructions but with</span></span><br><span class="line"><span class="comment"> * support for using temps as operands. *)</span></span><br><span class="line"><span class="keyword">type</span> inst = </span><br><span class="line">  <span class="type">Label</span> <span class="keyword">of</span> label</span><br><span class="line">| <span class="type">Move</span> <span class="keyword">of</span> operand * operand                     <span class="comment">(* x := y *)</span></span><br><span class="line">| <span class="type">Arith</span> <span class="keyword">of</span> operand * operand * arithop * operand <span class="comment">(* x := y + z *)</span></span><br><span class="line">| <span class="type">Load</span> <span class="keyword">of</span> operand * operand * <span class="built_in">int</span>               <span class="comment">(* x := *(y+i) *)</span></span><br><span class="line">| <span class="type">Store</span> <span class="keyword">of</span> operand * <span class="built_in">int</span> * operand              <span class="comment">(* *(x+i) := y *)</span></span><br><span class="line">| <span class="type">Call</span> <span class="keyword">of</span> operand                               <span class="comment">(* invoke f--result in R2 *)</span></span><br><span class="line">| <span class="type">Jump</span> <span class="keyword">of</span> label  <span class="comment">(* j L *)</span></span><br><span class="line">| <span class="type">If</span> <span class="keyword">of</span> operand * compareop * operand * label * label</span><br><span class="line">      <span class="comment">(* if x &lt; y then goto L1 else goto L2 *)</span></span><br><span class="line">| <span class="type">Return</span>  <span class="comment">(* return to caller -- result assumed in R2 *)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* basic blocks -- instead of capturing the structure of basic</span></span><br><span class="line"><span class="comment"> * blocks (as done in class), we just represent them as lists</span></span><br><span class="line"><span class="comment"> * of instructions where we assume that each block starts with a </span></span><br><span class="line"><span class="comment"> * Label and ends with either a Jump, If, or Return and that </span></span><br><span class="line"><span class="comment"> * there is no intervening Label, Jump, If, or Return. *)</span></span><br><span class="line"><span class="keyword">type</span> block = inst <span class="built_in">list</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">(* a function is a list of basic blocks -- the first block is</span></span><br><span class="line"><span class="comment"> * assumed to be the entry point to the function. *)</span></span><br><span class="line"><span class="keyword">type</span> func = block <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line"><span class="comment">(* a program is a list of functions -- the function named main</span></span><br><span class="line"><span class="comment"> * is considered the entry point. *)</span></span><br><span class="line"><span class="keyword">type</span> program = func <span class="built_in">list</span></span><br></pre></td></tr></table></figure>

<h2 id="Build-Control-Flow-Graph"><a href="#Build-Control-Flow-Graph" class="headerlink" title="Build Control Flow Graph"></a>Build Control Flow Graph</h2><p>The second step would be to connect blocks of instructions together, based on the final jump statement in each block. </p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> make_graph (f: func) : flow_graph = </span><br><span class="line">  <span class="keyword">let</span> graph = <span class="type">FGraph</span>.empty <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> graph_with_nodes = <span class="type">List</span>.fold_left (<span class="keyword">fun</span> acc_graph block -&gt; <span class="type">FGraph</span>.addNode (<span class="type">Block</span> block) acc_graph) graph f <span class="keyword">in</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> add_edges acc_graph block = </span><br><span class="line">    <span class="keyword">match</span> <span class="type">List</span>.rev block <span class="keyword">with</span> </span><br><span class="line">    | (<span class="type">Jump</span> label) :: _ -&gt; </span><br><span class="line">      <span class="keyword">let</span> target_block_node = find_block_with_label f label <span class="keyword">in</span></span><br><span class="line">      <span class="type">FGraph</span>.addEdge (<span class="type">Block</span> block) target_block_node acc_graph</span><br><span class="line">    | (<span class="type">If</span> (_, _, _, label_true, label_false)) :: _ -&gt; </span><br><span class="line">      <span class="keyword">let</span> true_block_node = find_block_with_label f label_true <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">let</span> false_block_node = find_block_with_label f label_false <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">let</span> graph_with_true_edge = <span class="type">FGraph</span>.addEdge (<span class="type">Block</span> block) true_block_node acc_graph <span class="keyword">in</span></span><br><span class="line">      <span class="type">FGraph</span>.addEdge (<span class="type">Block</span> block) false_block_node graph_with_true_edge</span><br><span class="line">    | <span class="type">Return</span> :: _ -&gt; acc_graph</span><br><span class="line">    | _ -&gt; raise <span class="type">BlockError</span></span><br><span class="line">  <span class="keyword">in</span></span><br><span class="line">  <span class="type">List</span>.fold_left add_edges graph_with_nodes f</span><br></pre></td></tr></table></figure>

<p>There are only two cases that we need to consider, a jump and a if branch. We simply iterate over the list of blocks, which is of type func, and fold the result. </p>
<h2 id="Def-and-Use-Map-for-each-block-Kill-and-Gen-in-other-words"><a href="#Def-and-Use-Map-for-each-block-Kill-and-Gen-in-other-words" class="headerlink" title="Def and Use Map for each block (Kill and Gen in other words)"></a>Def and Use Map for each block (Kill and Gen in other words)</h2><p>This is an optimization to make the convergence of dataflow analysis faster, so that we do not have to recalculate the gen and kill at each iteration. </p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> process_instruction (def, use) inst = </span><br><span class="line">  <span class="keyword">match</span> inst <span class="keyword">with</span> </span><br><span class="line">  | <span class="type">Move</span> (dest, src) -&gt;</span><br><span class="line">    <span class="keyword">let</span> use = (</span><br><span class="line">      <span class="keyword">match</span> dest <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">VarNode</span> v) use) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">VarNode</span> v) use <span class="keyword">else</span> use)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">RegNode</span> r) use) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">RegNode</span> r) use <span class="keyword">else</span> use)</span><br><span class="line">      | _ -&gt; use</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> def = (</span><br><span class="line">      <span class="keyword">match</span> src <span class="keyword">with</span></span><br><span class="line">      | <span class="type">Var</span> v -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">VarNode</span> v) def) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">VarNode</span> v) def <span class="keyword">else</span> def)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">RegNode</span> r) def) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">RegNode</span> r) def <span class="keyword">else</span> def)</span><br><span class="line">      | _ -&gt; def</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> (def, use) = (</span><br><span class="line">      <span class="keyword">match</span> dest <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (add_node_to_def def (<span class="type">VarNode</span> v), use)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (add_node_to_def def (<span class="type">RegNode</span> r), use)</span><br><span class="line">      | _ -&gt; (def, use)</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> (def, use) = (</span><br><span class="line">      <span class="keyword">match</span> src <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (def, add_node_to_use use (<span class="type">VarNode</span> v))</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (def, add_node_to_use use (<span class="type">RegNode</span> r))</span><br><span class="line">      | _ -&gt; (def, use)</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    (def, use)</span><br><span class="line">  | <span class="type">Arith</span> (dest, src, _, src2) -&gt; </span><br><span class="line">    <span class="keyword">let</span> use = (</span><br><span class="line">      <span class="keyword">match</span> dest <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">VarNode</span> v) use) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">VarNode</span> v) use <span class="keyword">else</span> use)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">RegNode</span> r) use) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">RegNode</span> r) use <span class="keyword">else</span> use)</span><br><span class="line">      | _ -&gt; use</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> def = (</span><br><span class="line">      <span class="keyword">match</span> src <span class="keyword">with</span></span><br><span class="line">      | <span class="type">Var</span> v -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">VarNode</span> v) def) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">VarNode</span> v) def <span class="keyword">else</span> def)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">RegNode</span> r) def) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">RegNode</span> r) def <span class="keyword">else</span> def)</span><br><span class="line">      | _ -&gt; def</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> def = (</span><br><span class="line">      <span class="keyword">match</span> src2 <span class="keyword">with</span></span><br><span class="line">      | <span class="type">Var</span> v -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">VarNode</span> v) def) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">VarNode</span> v) def <span class="keyword">else</span> def)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">RegNode</span> r) def) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">RegNode</span> r) def <span class="keyword">else</span> def)</span><br><span class="line">      | _ -&gt; def</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> (def, use) = <span class="keyword">match</span> dest <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (add_node_to_def def (<span class="type">VarNode</span> v), use)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (add_node_to_def def (<span class="type">RegNode</span> r), use)</span><br><span class="line">      | _ -&gt; (def, use)</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> (def, use)= <span class="keyword">match</span> src <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (def, add_node_to_use use (<span class="type">VarNode</span> v))</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (def, add_node_to_use use (<span class="type">RegNode</span> r))</span><br><span class="line">      | _ -&gt; (def, use)</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> (def, use) = <span class="keyword">match</span> src2 <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (def, add_node_to_use use (<span class="type">VarNode</span> v))</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (def, add_node_to_use use (<span class="type">RegNode</span> r))</span><br><span class="line">      | _ -&gt; (def, use)</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    (def, use)</span><br><span class="line">  | <span class="type">If</span> (src1, _, src2, _, _) -&gt; </span><br><span class="line">    <span class="keyword">let</span> (def, use) = (</span><br><span class="line">      <span class="keyword">match</span> src1 <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (def, add_node_to_use use (<span class="type">VarNode</span> v))</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (def, add_node_to_use use (<span class="type">RegNode</span> r))</span><br><span class="line">      | _ -&gt; (def, use)</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> (def, use) = (</span><br><span class="line">      <span class="keyword">match</span> src2 <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (def, add_node_to_use use (<span class="type">VarNode</span> v))</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (def, add_node_to_use use (<span class="type">RegNode</span> r))</span><br><span class="line">      | _ -&gt; (def, use)</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    (def, use)</span><br><span class="line">  | <span class="type">Load</span> (dest, src, _) -&gt; </span><br><span class="line">    <span class="keyword">let</span> use = (</span><br><span class="line">      <span class="keyword">match</span> dest <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">VarNode</span> v) use) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">VarNode</span> v) use <span class="keyword">else</span> use)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">RegNode</span> r) use) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">RegNode</span> r) use <span class="keyword">else</span> use)</span><br><span class="line">      | _ -&gt; use</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> def = (</span><br><span class="line">      <span class="keyword">match</span> src <span class="keyword">with</span></span><br><span class="line">      | <span class="type">Var</span> v -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">VarNode</span> v) def) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">VarNode</span> v) def <span class="keyword">else</span> def)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">RegNode</span> r) def) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">RegNode</span> r) def <span class="keyword">else</span> def)</span><br><span class="line">      | _ -&gt; def</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> (def, use) = (</span><br><span class="line">      <span class="keyword">match</span> dest <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (add_node_to_def def (<span class="type">VarNode</span> v), use)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (add_node_to_def def (<span class="type">RegNode</span> r), use)</span><br><span class="line">      | _ -&gt; (def, use)</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> (def, use) = (</span><br><span class="line">      <span class="keyword">match</span> src <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (def, add_node_to_use use (<span class="type">VarNode</span> v))</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (def, add_node_to_use use (<span class="type">RegNode</span> r))</span><br><span class="line">      | _ -&gt; (def, use)</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    (def, use)</span><br><span class="line">  | <span class="type">Store</span> (_, _, src) -&gt; </span><br><span class="line">    <span class="keyword">let</span> def = (</span><br><span class="line">      <span class="keyword">match</span> src <span class="keyword">with</span></span><br><span class="line">      | <span class="type">Var</span> v -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">VarNode</span> v) def) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">VarNode</span> v) def <span class="keyword">else</span> def)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">RegNode</span> r) def) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">RegNode</span> r) def <span class="keyword">else</span> def)</span><br><span class="line">      | _ -&gt; def</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> (def, use) = (</span><br><span class="line">      <span class="keyword">match</span> src <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (def, add_node_to_use use (<span class="type">VarNode</span> v))</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (def, add_node_to_use use (<span class="type">RegNode</span> r))</span><br><span class="line">      | _ -&gt; (def, use)</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    (def, use)</span><br><span class="line">    <span class="comment">(* Pending, do not know precisely how to handle the call case *)</span></span><br><span class="line">  | <span class="type">Call</span> _ -&gt; </span><br><span class="line">    <span class="keyword">let</span> def = (<span class="type">NodeSet</span>.union (<span class="type">NodeSet</span>.of_list (<span class="type">List</span>.map (<span class="keyword">fun</span> x -&gt; <span class="type">RegNode</span> x) call_kill_list_reg)) def) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> use = (<span class="type">NodeSet</span>.union (<span class="type">NodeSet</span>.of_list (<span class="type">List</span>.map (<span class="keyword">fun</span> x -&gt; <span class="type">RegNode</span> x) call_gen_list_reg)) use) <span class="keyword">in</span></span><br><span class="line">    (def, use)</span><br><span class="line">  | <span class="type">Return</span> -&gt; </span><br><span class="line">    <span class="keyword">let</span> def = (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">RegNode</span> <span class="type">R2</span>) def) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">RegNode</span> <span class="type">R2</span>) def <span class="keyword">else</span> def)</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> use = <span class="type">NodeSet</span>.add (<span class="type">RegNode</span> <span class="type">R2</span>) use <span class="keyword">in</span></span><br><span class="line">    (def, use)</span><br><span class="line">  | _ -&gt; (def, use)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> update_maps block (def_map, use_map) =</span><br><span class="line">  <span class="keyword">let</span> instructions = <span class="type">List</span>.rev block <span class="keyword">in</span> </span><br><span class="line">  <span class="keyword">let</span> def, use = <span class="type">List</span>.fold_left process_instruction (<span class="type">NodeSet</span>.empty, <span class="type">NodeSet</span>.empty) instructions <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> block_node = <span class="type">Block</span> block <span class="keyword">in</span></span><br><span class="line">  (<span class="type">BlockMap</span>.add block_node def def_map, <span class="type">BlockMap</span>.add block_node use use_map)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> build_maps (f: func) = <span class="type">List</span>.fold_left (<span class="keyword">fun</span> maps block -&gt; update_maps block maps) (<span class="type">BlockMap</span>.empty, <span class="type">BlockMap</span>.empty) f </span><br></pre></td></tr></table></figure>

<p>Let me just make an important remark on the definition of the gen and kill set of each block. (or def and use in the Appel’s book, which is equivalent). I want to emphasize that because it is not in Appel’s book (Appel did not use the block coalesce optimization, which merge together non jump instructions). Nor does Prof Joe thought of it immediately. </p>
<ol>
<li>A def set of a block is the set of variables that are defined before ever used in that block. </li>
<li>A use set is, on the contrary, the set of variables that are used before ever defined.</li>
</ol>
<p>So, when doing the def use summary of the block, you start from the bottom, and if you see a variable defined, then you should remove it from the use set, if it exists in the use set. </p>
<h2 id="Liveness-Analysis"><a href="#Liveness-Analysis" class="headerlink" title="Liveness Analysis"></a>Liveness Analysis</h2><p>The liveness analysis algorithm is well established. We just need to implement it in ocaml. </p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> analyze_liveness flow_graph def_use_map live_in_sets live_out_sets =</span><br><span class="line">  <span class="keyword">let</span> changes = <span class="built_in">ref</span> <span class="literal">false</span> <span class="keyword">in</span> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> new_live_in_sets, new_live_out_sets = </span><br><span class="line"></span><br><span class="line">    <span class="type">FlowNodeSet</span>.fold (<span class="keyword">fun</span> block_node (acc_live_in_sets, acc_live_out_sets) -&gt; </span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> gen_set = <span class="type">BlockMap</span>.find block_node (snd def_use_map) <span class="keyword">in</span> </span><br><span class="line">      <span class="keyword">let</span> kill_set = <span class="type">BlockMap</span>.find block_node (fst def_use_map) <span class="keyword">in</span> </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">let</span> live_out = <span class="type">FlowNodeSet</span>.fold(<span class="keyword">fun</span> succ live_out_acc -&gt; </span><br><span class="line">        <span class="keyword">let</span> succ_live_in = <span class="keyword">try</span> <span class="type">BlockMap</span>.find succ acc_live_in_sets <span class="keyword">with</span> <span class="type">Not_found</span> -&gt; <span class="type">NodeSet</span>.empty <span class="keyword">in</span></span><br><span class="line">        <span class="type">NodeSet</span>.union succ_live_in live_out_acc</span><br><span class="line">      ) (<span class="type">FGraph</span>.succ block_node flow_graph) <span class="type">NodeSet</span>.empty <span class="keyword">in</span> </span><br><span class="line"></span><br><span class="line">      print_endline <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;live out&quot;</span>;</span><br><span class="line">      print_blocknode block_node;</span><br><span class="line">      print_set live_out;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> live_in = <span class="type">NodeSet</span>.union gen_set (<span class="type">NodeSet</span>.diff live_out kill_set) <span class="keyword">in</span></span><br><span class="line">      print_endline <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;live in&quot;</span>;</span><br><span class="line">      print_blocknode block_node;</span><br><span class="line">      print_set live_in;</span><br><span class="line">      <span class="keyword">let</span> prev_live_in = <span class="keyword">try</span> <span class="type">BlockMap</span>.find block_node acc_live_in_sets <span class="keyword">with</span> <span class="type">Not_found</span> -&gt; <span class="type">NodeSet</span>.empty <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">let</span> prev_live_out = <span class="keyword">try</span> <span class="type">BlockMap</span>.find block_node acc_live_out_sets <span class="keyword">with</span> <span class="type">Not_found</span> -&gt; <span class="type">NodeSet</span>.empty <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="type">NodeSet</span>.equal live_out prev_live_out) <span class="keyword">then</span> (</span><br><span class="line">        print_endline <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;nothing changes, cont to next block&quot;</span>;</span><br><span class="line">        <span class="keyword">let</span> updated_live_in_sets = <span class="type">BlockMap</span>.add block_node prev_live_in acc_live_in_sets <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> updated_live_out_sets = <span class="type">BlockMap</span>.add block_node prev_live_out acc_live_out_sets <span class="keyword">in</span></span><br><span class="line">        (updated_live_in_sets, updated_live_out_sets)</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">else</span> (</span><br><span class="line">        changes := <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">let</span> updated_live_in_sets = <span class="type">BlockMap</span>.add block_node live_in acc_live_in_sets <span class="keyword">in</span> </span><br><span class="line">        <span class="keyword">let</span> updated_live_out_sets = <span class="type">BlockMap</span>.add block_node live_out acc_live_out_sets <span class="keyword">in</span></span><br><span class="line">        (updated_live_in_sets, updated_live_out_sets)</span><br><span class="line">      )</span><br><span class="line">    ) (<span class="type">FGraph</span>.nodes flow_graph) (live_in_sets, live_out_sets) </span><br><span class="line">  <span class="keyword">in</span> <span class="keyword">if</span> !changes <span class="keyword">then</span> analyze_liveness flow_graph def_use_map new_live_in_sets new_live_out_sets <span class="keyword">else</span> (new_live_in_sets, new_live_out_sets)</span><br></pre></td></tr></table></figure>

<p>What I implemented is just a relatively truthful ocaml version of this algorithm. </p>
<p><img src="/images/liveness_analyze.png"></p>
<h2 id="Construct-Interference-Graph"><a href="#Construct-Interference-Graph" class="headerlink" title="Construct Interference Graph"></a>Construct Interference Graph</h2><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add_edges_to_igraph (live_in_sets: <span class="type">NodeSet</span>.t <span class="type">BlockMap</span>.t) (live_out_sets: <span class="type">NodeSet</span>.t <span class="type">BlockMap</span>.t): interfere_graph =</span><br><span class="line">  <span class="keyword">let</span> interfere_graph = <span class="type">IUGraph</span>.empty <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> add_interferences block_live_out graph = </span><br><span class="line">    <span class="type">NodeSet</span>.fold (<span class="keyword">fun</span> node acc_graph -&gt; </span><br><span class="line">      <span class="type">NodeSet</span>.fold (<span class="keyword">fun</span> other_node acc_inner_graph -&gt;</span><br><span class="line">        specialAddEdge node other_node acc_inner_graph</span><br><span class="line">      ) block_live_out acc_graph</span><br><span class="line">    ) block_live_out graph</span><br><span class="line">  <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> combined_sets = <span class="type">BlockMap</span>.merge (<span class="keyword">fun</span> _ live_in live_out -&gt;</span><br><span class="line">    <span class="keyword">match</span> live_in, live_out <span class="keyword">with</span></span><br><span class="line">    | <span class="type">Some</span> ins, <span class="type">Some</span> outs -&gt; <span class="type">Some</span> (<span class="type">NodeSet</span>.union ins outs)</span><br><span class="line">    | <span class="type">Some</span> ins, <span class="type">None</span> -&gt; <span class="type">Some</span> ins</span><br><span class="line">    | <span class="type">None</span>, <span class="type">Some</span> outs -&gt; <span class="type">Some</span> outs</span><br><span class="line">    | <span class="type">None</span>, <span class="type">None</span> -&gt; <span class="type">None</span></span><br><span class="line">  ) live_in_sets live_out_sets <span class="keyword">in</span></span><br><span class="line">  <span class="type">BlockMap</span>.fold (<span class="keyword">fun</span> _ combined_live_set acc_graph -&gt; </span><br><span class="line">    add_interferences combined_live_set acc_graph</span><br><span class="line">  ) combined_sets interfere_graph</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instruction_def_use live_set inst = </span><br><span class="line">  <span class="keyword">match</span> inst <span class="keyword">with</span> </span><br><span class="line">  | <span class="type">Move</span> (dest, src) -&gt;</span><br><span class="line">    <span class="keyword">let</span> live_set = (</span><br><span class="line">      <span class="keyword">match</span> dest <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">VarNode</span> v) live_set) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">VarNode</span> v) live_set <span class="keyword">else</span> live_set)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">RegNode</span> r) live_set) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">RegNode</span> r) live_set <span class="keyword">else</span> live_set)</span><br><span class="line">      | _ -&gt; live_set</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> live_set = (</span><br><span class="line">      <span class="keyword">match</span> src <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; add_node_to_use live_set (<span class="type">VarNode</span> v)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; add_node_to_use live_set (<span class="type">RegNode</span> r)</span><br><span class="line">      | _ -&gt; live_set</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    live_set</span><br><span class="line">  | <span class="type">Arith</span> (dest, src, _, src2) -&gt; </span><br><span class="line">    <span class="keyword">let</span> live_set = (</span><br><span class="line">      <span class="keyword">match</span> dest <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">VarNode</span> v) live_set) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">VarNode</span> v) live_set <span class="keyword">else</span> live_set)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">RegNode</span> r) live_set) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">RegNode</span> r) live_set <span class="keyword">else</span> live_set)</span><br><span class="line">      | _ -&gt; live_set</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> live_set= <span class="keyword">match</span> src <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; add_node_to_use live_set (<span class="type">VarNode</span> v)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; add_node_to_use live_set (<span class="type">RegNode</span> r)</span><br><span class="line">      | _ -&gt; live_set</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> live_set = <span class="keyword">match</span> src2 <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; add_node_to_use live_set (<span class="type">VarNode</span> v)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; add_node_to_use live_set (<span class="type">RegNode</span> r)</span><br><span class="line">      | _ -&gt; live_set</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    live_set</span><br><span class="line">  | <span class="type">If</span> (src1, _, src2, _, _) -&gt; </span><br><span class="line">    <span class="keyword">let</span> live_set = (</span><br><span class="line">      <span class="keyword">match</span> src1 <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; add_node_to_use live_set (<span class="type">VarNode</span> v)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; add_node_to_use live_set (<span class="type">RegNode</span> r)</span><br><span class="line">      | _ -&gt; live_set</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> live_set = (</span><br><span class="line">      <span class="keyword">match</span> src2 <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; add_node_to_use live_set (<span class="type">VarNode</span> v)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; add_node_to_use live_set (<span class="type">RegNode</span> r)</span><br><span class="line">      | _ -&gt; live_set</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    live_set</span><br><span class="line">  | <span class="type">Load</span> (dest, src, _) -&gt; </span><br><span class="line">    <span class="keyword">let</span> live_set = (</span><br><span class="line">      <span class="keyword">match</span> dest <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">VarNode</span> v) live_set) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">VarNode</span> v) live_set <span class="keyword">else</span> live_set)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; (<span class="keyword">if</span> (<span class="type">NodeSet</span>.mem (<span class="type">RegNode</span> r) live_set) <span class="keyword">then</span> <span class="type">NodeSet</span>.remove (<span class="type">RegNode</span> r) live_set <span class="keyword">else</span> live_set)</span><br><span class="line">      | _ -&gt; live_set</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> live_set = (</span><br><span class="line">      <span class="keyword">match</span> src <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; add_node_to_use live_set (<span class="type">VarNode</span> v)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; add_node_to_use live_set (<span class="type">RegNode</span> r)</span><br><span class="line">      | _ -&gt; live_set</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    live_set</span><br><span class="line">  | <span class="type">Store</span> (_, _, src) -&gt; </span><br><span class="line">    <span class="keyword">let</span> live_set = (</span><br><span class="line">      <span class="keyword">match</span> src <span class="keyword">with</span> </span><br><span class="line">      | <span class="type">Var</span> v -&gt; add_node_to_use live_set (<span class="type">VarNode</span> v)</span><br><span class="line">      | <span class="type">Reg</span> r -&gt; add_node_to_use live_set (<span class="type">RegNode</span> r)</span><br><span class="line">      | _ -&gt; live_set</span><br><span class="line">    ) <span class="keyword">in</span></span><br><span class="line">    live_set</span><br><span class="line">    <span class="comment">(* Pending, do not know precisely how to handle the call case *)</span></span><br><span class="line">  | <span class="type">Call</span> _ -&gt; </span><br><span class="line">    <span class="keyword">let</span> live_set = (<span class="type">NodeSet</span>.union (<span class="type">NodeSet</span>.of_list (<span class="type">List</span>.map (<span class="keyword">fun</span> x -&gt; <span class="type">RegNode</span> x) call_kill_list_reg)) live_set) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> live_set = (<span class="type">NodeSet</span>.union (<span class="type">NodeSet</span>.of_list (<span class="type">List</span>.map (<span class="keyword">fun</span> x -&gt; <span class="type">RegNode</span> x) call_gen_list_reg)) live_set) <span class="keyword">in</span></span><br><span class="line">    live_set</span><br><span class="line">  | _ -&gt; live_set</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> build_interference_graph (blocks: block <span class="built_in">list</span>) (live_out_map: <span class="type">NodeSet</span>.t <span class="type">BlockMap</span>.t) = </span><br><span class="line">  <span class="keyword">let</span> interfere_graph = <span class="type">IUGraph</span>.empty <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> add_interference g n1 n2 = specialAddEdge n1 n2 g <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> add_interference_for_set g live_set =</span><br><span class="line">    <span class="type">NodeSet</span>.fold (<span class="keyword">fun</span> node acc_graph -&gt;</span><br><span class="line">      <span class="type">NodeSet</span>.fold (<span class="keyword">fun</span> other_node inner_acc_graph -&gt;</span><br><span class="line">        add_interference inner_acc_graph node other_node</span><br><span class="line">      ) live_set acc_graph</span><br><span class="line">    ) live_set g</span><br><span class="line">  <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> process_block block live_out acc_graph = </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> handle_instruction instrs live_set graph = </span><br><span class="line">      <span class="keyword">match</span> instrs <span class="keyword">with</span></span><br><span class="line">      | <span class="literal">[]</span> -&gt; graph</span><br><span class="line">      | instr::rest -&gt;</span><br><span class="line">        <span class="comment">(* let defined, used = instruction_def_use instr in </span></span><br><span class="line"><span class="comment">        let new_live_set = NodeSet.union (NodeSet.diff live_set defined) used in *)</span></span><br><span class="line">        <span class="keyword">let</span> new_live_set = instruction_def_use live_set instr <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> new_graph = add_interference_for_set graph new_live_set <span class="keyword">in</span></span><br><span class="line">        handle_instruction rest new_live_set new_graph</span><br><span class="line">    <span class="keyword">in</span></span><br><span class="line">    handle_instruction (<span class="type">List</span>.rev block) live_out acc_graph</span><br><span class="line">  <span class="keyword">in</span> </span><br><span class="line">  <span class="type">BlockMap</span>.fold (<span class="keyword">fun</span> block live_out acc_graph -&gt; </span><br><span class="line">    <span class="keyword">match</span> block <span class="keyword">with</span></span><br><span class="line">    | <span class="type">Block</span> b -&gt; process_block b live_out acc_graph</span><br><span class="line">    | _ -&gt; raise <span class="type">FatalError</span> <span class="string">&quot;BlockMap should only contain blocks&quot;</span></span><br><span class="line">  ) live_out_map interfere_graph</span><br></pre></td></tr></table></figure>

<p>To construct interference graph, we use the live-out set for each block as a starting point, move backward, take out and add in variables to the live set along the way, according to the gen and kill rules. At each instruction step, we add edges between every 2 nodes in the live set, to the interference graph. </p>
<h2 id="Putting-everything-together"><a href="#Putting-everything-together" class="headerlink" title="Putting everything together"></a>Putting everything together</h2><p>I wrote a main function to put everythong together. </p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> build_interfere_graph (f : func) = </span><br><span class="line">    <span class="keyword">let</span> flow_graph = make_graph f <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> def_use_map = build_maps f <span class="keyword">in</span></span><br><span class="line">    print_endline <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>;</span><br><span class="line">    print_endline <span class="string">&quot;Def Map:&quot;</span>;</span><br><span class="line">    print_map (fst def_use_map);</span><br><span class="line">    print_endline <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>;</span><br><span class="line">    print_endline <span class="string">&quot;Use Map:&quot;</span>;</span><br><span class="line">    print_map (snd def_use_map);</span><br><span class="line">    print_endline <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>;</span><br><span class="line">    print_endline <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> initial_live_out_sets = <span class="type">BlockMap</span>.empty <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> final_live_in_sets, final_live_out_sets = analyze_liveness flow_graph def_use_map (snd def_use_map) initial_live_out_sets <span class="keyword">in</span></span><br><span class="line">    print_endline <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>;</span><br><span class="line">    print_endline <span class="string">&quot;Live In Sets:&quot;</span>;</span><br><span class="line">    print_map final_live_in_sets;</span><br><span class="line">    print_endline <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>;</span><br><span class="line">    print_endline <span class="string">&quot;Live Out Sets:&quot;</span>;</span><br><span class="line">    print_map final_live_out_sets;</span><br><span class="line">    <span class="keyword">let</span> final_interfere_graph = build_interference_graph f final_live_out_sets <span class="keyword">in</span></span><br><span class="line">    final_interfere_graph</span><br></pre></td></tr></table></figure>




</div><div class="article-licensing box"><div class="licensing-title"><p>[Compiler Construction] Control Flow Graph, Liveness Analysis, Dataflow Analysis and Interference Graph, Implemented in OCaml</p><p><a href="http://peteryaonyu.github.io/2024/04/17/Compiler-Construction-Control-Flow-Graph-Liveness-Analysis-Dataflow-Analysis-and-Interference-Graph-Implemented-in-OCaml/">http://peteryaonyu.github.io/2024/04/17/Compiler-Construction-Control-Flow-Graph-Liveness-Analysis-Dataflow-Analysis-and-Interference-Graph-Implemented-in-OCaml/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Yuncheng Yao</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-04-17</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-04-17</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Compiler/">Compiler</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/04/07/Compiler-Construction-in-Ocaml-Hindley-Milner-Type-Inference-System-Implementation/"><span class="level-item">[Compiler Construction in Ocaml] Hindley-Milner Type Inference System Implementation</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="Yao Yuncheng (Peter)"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Yao Yuncheng (Peter)</p><p class="is-size-6 is-block">yy4108@nyu.edu</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/PeterYaoNYU" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/PeterYaoNYU"><i class="fab fa-github"></i></a></div></div></div><!--!--><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-17T23:53:06.000Z">2024-04-17</time></p><p class="title"><a href="/2024/04/17/Compiler-Construction-Control-Flow-Graph-Liveness-Analysis-Dataflow-Analysis-and-Interference-Graph-Implemented-in-OCaml/">[Compiler Construction] Control Flow Graph, Liveness Analysis, Dataflow Analysis and Interference Graph, Implemented in OCaml</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-08T02:25:07.000Z">2024-04-07</time></p><p class="title"><a href="/2024/04/07/Compiler-Construction-in-Ocaml-Hindley-Milner-Type-Inference-System-Implementation/">[Compiler Construction in Ocaml] Hindley-Milner Type Inference System Implementation</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-14T03:36:41.000Z">2024-01-13</time></p><p class="title"><a href="/2024/01/13/Database-Implementation-of-an-Entendible-Hash-Index/">[Database] Implementation of an Entendible Hash Index</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-12T09:12:17.000Z">2024-01-12</time></p><p class="title"><a href="/2024/01/12/Consensus-Raft-from-Scratch-Leader-Election/">[Consensus] Raft from Scratch: Leader Election</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-09T04:21:48.000Z">2024-01-08</time></p><p class="title"><a href="/2024/01/08/Implementing-a-MapReduce-Framework-with-Golang-from-scratch/">Implementing a MapReduce Framework with Golang RPC from scratch</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Compiler/"><span class="tag">Compiler</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Database-Systems/"><span class="tag">Database Systems</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Distribute-Systems/"><span class="tag">Distribute Systems</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-Systems/"><span class="tag">Operating Systems</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Yao Yuncheng(Peter)</a><p class="is-size-7"><span>&copy; 2024 Yuncheng Yao</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PeterYaoNYU"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>