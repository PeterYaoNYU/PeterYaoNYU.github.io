<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>[Compiler Construction in Ocaml] Hindley-Milner Type Inference System Implementation - Peter Yuncheng Yao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Peter&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Peter&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="I want to spend some time talking about implementing Hindley-Milner type inference system in Ocaml for a ML-ish langauge. The code is available at my Github, under ps6&amp;#x2F;mlish_type_check.ml."><meta property="og:type" content="blog"><meta property="og:title" content="[Compiler Construction in Ocaml] Hindley-Milner Type Inference System Implementation"><meta property="og:url" content="http://peteryaonyu.github.io/2024/04/07/Compiler-Construction-in-Ocaml-Hindley-Milner-Type-Inference-System-Implementation/"><meta property="og:site_name" content="Peter Yuncheng Yao"><meta property="og:description" content="I want to spend some time talking about implementing Hindley-Milner type inference system in Ocaml for a ML-ish langauge. The code is available at my Github, under ps6&amp;#x2F;mlish_type_check.ml."><meta property="og:locale" content="en_US"><meta property="og:image" content="https://avatars.githubusercontent.com/u/93311390?v=4"><meta property="og:image" content="http://peteryaonyu.github.io/images/occurs-type-inference.png"><meta property="og:image" content="http://peteryaonyu.github.io/images/unify2guesses.png"><meta property="article:published_time" content="2024-04-08T02:25:07.000Z"><meta property="article:modified_time" content="2024-04-08T03:33:05.125Z"><meta property="article:author" content="Yuncheng Yao"><meta property="article:tag" content="Peter Yuncheng Yao, Peter Yao, Peter Y. Yao, Peter Yao NYU, Peter Yao NYU Shanghai, Peter Yao NYUSH, Peter Yao NYU S"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://avatars.githubusercontent.com/u/93311390?v=4"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://peteryaonyu.github.io/2024/04/07/Compiler-Construction-in-Ocaml-Hindley-Milner-Type-Inference-System-Implementation/"},"headline":"[Compiler Construction in Ocaml] Hindley-Milner Type Inference System Implementation","image":["http://peteryaonyu.github.io/images/occurs-type-inference.png","http://peteryaonyu.github.io/images/unify2guesses.png"],"datePublished":"2024-04-08T02:25:07.000Z","dateModified":"2024-04-08T03:33:05.125Z","author":{"@type":"Person","name":"Yuncheng Yao"},"publisher":{"@type":"Organization","name":"Peter Yuncheng Yao","logo":{"@type":"ImageObject","url":{"text":"Yao Yuncheng(Peter)"}}},"description":"I want to spend some time talking about implementing Hindley-Milner type inference system in Ocaml for a ML-ish langauge. The code is available at my Github, under ps6&#x2F;mlish_type_check.ml."}</script><link rel="canonical" href="http://peteryaonyu.github.io/2024/04/07/Compiler-Construction-in-Ocaml-Hindley-Milner-Type-Inference-System-Implementation/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Peter Yuncheng Yao" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Yao Yuncheng(Peter)</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/CV">CV</a><a class="navbar-item" href="/publication">Publication</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PeterYaoNYU"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-04-08T02:25:07.000Z" title="4/7/2024, 10:25:07 PM">2024-04-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-04-08T03:33:05.125Z" title="4/7/2024, 11:33:05 PM">2024-04-07</time></span><span class="level-item">15 minutes read (About 2317 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">[Compiler Construction in Ocaml] Hindley-Milner Type Inference System Implementation</h1><div class="content"><p>I want to spend some time talking about implementing Hindley-Milner type inference system in Ocaml for a ML-ish langauge. The code is available at my Github, under ps6&#x2F;mlish_type_check.ml. </p>
<style>
                /* css part */
                .gr-card {

                    --gr-header-width-proportion: 10%;
                    --gr-footer-width-proportion: 10%;
                    --gr-content-width-proportion: 80%;

                    --gr-header-min-width: 80px;
                    --gr-footer-min-width: 80px;

                    --gr-card-element-margin: 6px 10px 6px 10px; /* header content footer*/

                    display: flex;
                    background-color: #fff;
                    border-radius: 6px;
                    overflow: hidden;
                    box-shadow: 0px 4px 6px rgba(0, 0, 0, .12);
                    margin-bottom: 20px;
                    vertical-align: middle;
                    position: relative;
                }

                .gr-header {
                    width: var(--gr-header-width-proportion);
                    min-width: var(--gr-header-min-width);
                    margin: var(--gr-card-element-margin);
                    background-color: #fff;
                    /* background-color: blueviolet; */
                }

                .gr-header img {
                    width: 80px;
                    height: 80px;
                    position: relative;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%,-50%);
                    object-fit: cover;
                    border-radius: 50%;
                    margin: 0px;
                }

                .gr-content {
                    width: var(--gr-content-width-proportion);
                    margin: var(--gr-card-element-margin);
                    background-color: #fff;
                    text-align: left;
                }

                #gr-github-icon {
                    font-size: 1.3rem;
                }
                .gr-fullname {
                    display: -webkit-box;
                    -webkit-box-orient: vertical;
                    -webkit-line-clamp: 1;
                    overflow: hidden;
                }

                .gr-fullname p {
                    line-height: 2rem;
                    margin: 10px 0px 0px 0px;
                    padding: 0;
                    font-size: .83rem;
                    font-weight: bolder;
                }

                .gr-description {
                    font-size: .8rem;
                    line-height: 1.6rem;
                    display: -webkit-box;
                    -webkit-box-orient: vertical;
                    -webkit-line-clamp: 1;
                    overflow: hidden;
                }

                .gr-footer {
                    width: var(--gr-footer-width-proportion);
                    min-width: var(--gr-footer-min-width);
                    margin: var(--gr-card-element-margin);
                    display: flex;
                    /* background-color: aqua; */
                    background-color: #fff;
                    position: relative;
                    padding: 0px;
                }

                .gr-language-star {
                    margin: auto auto 22px auto;
                    text-align: center;
                    opacity: 1;
                }

                .gr-language {
                    font-size: .8rem;
                    font-weight: 600;
                    line-height: 2.2rem;
                    color: #2070d3;
                }

                #gr-star-icon {
                    font-size: .8rem;
                    display: inherit;
                }

                .gr-card-toolbar{
                    display:flex;
                    width: 100%;
                    height: 100%;

                    position: absolute;

                    opacity: 0;
                    animation: fade-out;
                    animation-duration: .4s;
                    z-index: -1;
                    /* background-color: #2070d3; */
                }

                .gr-repo-link {
                    margin: auto;
                }

                #gr-repo-link-icon {
                    font-size: 16px;
                }
                /* animation part */

                @keyframes fade-in {
                    0% {opacity: 0;}/*初始状态 透明度为0*/
                    100% {opacity: 1;}/*结束状态 透明度为1*/
                }

                @keyframes fade-out {
                    0% {opacity: 1;}/*初始状态 透明度为0*/
                    100% {opacity: 0;}/*结束状态 透明度为1*/
                }

                .gr-card:hover .gr-language-star{
                    opacity: 0;
                    animation: fade-out;
                    animation-duration: .3s;
                }

                .gr-card:hover .gr-card-toolbar{
                    opacity: 1;
                    animation: fade-in;
                    animation-duration: .6s;
                    z-index: 1;
                }
                </style>

                <div class="gr-card">
                    <div class="gr-header">
                        <img src="https://avatars.githubusercontent.com/u/93311390?v=4" alt="">
                    </div>
                    <div class="gr-content">
                        <div class="gr-fullname">
                            <p><i class="fab fa-github fa-lg" aria-hidden="true" id="gr-github-icon"></i> PeterYaoNYU/CompilerInOCaml</p>
                        </div>
                        <div class="gr-description">
                            A compiler for a C-ish language, implemeted in OCaml
                        </div>
                    </div>
                    <div class="gr-footer">
                        <div class="gr-language-star">
                            <span class="gr-language">OCaml</span>
                            <i class="far fa-star" aria-hidden="true" id='gr-star-icon'> 0</i>
                        </div>
                        <div class="gr-card-toolbar">
                            <div class="gr-repo-link">
                                <a href="https://github.com/PeterYaoNYU/CompilerInOCaml" target="_blank" rel="noopener noreferrer"
                                    title="Open in a new TAB">
                                    <i class="fas fa-external-link-square-alt fa-lg" aria-hidden="true" style="color: black;" id="gr-repo-link-icon"></i>
                                </a>
                            </div>
                        </div>
                    </div>
                </div>

<p>This is part of the project for NYU graduate level capstone course by Prof. Joseph Tassarotti. </p>
<span id="more"></span>

<h2 id="AST-for-ML"><a href="#AST-for-ML" class="headerlink" title="AST for ML"></a>AST for ML</h2><p>Before delving into the implementation of the type inference system, let me first provide you with the AST for the ML-ish language that we are doing type inference on:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> var = <span class="built_in">string</span>   <span class="comment">(* program variables *)</span></span><br><span class="line"><span class="keyword">type</span> tvar = <span class="built_in">string</span>  <span class="comment">(* type variables *)</span></span><br><span class="line"><span class="keyword">type</span> pos = <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tipe = </span><br><span class="line">  <span class="type">Tvar_t</span> <span class="keyword">of</span> tvar</span><br><span class="line">| <span class="type">Int_t</span></span><br><span class="line">| <span class="type">Bool_t</span></span><br><span class="line">| <span class="type">Unit_t</span></span><br><span class="line">| <span class="type">Fn_t</span> <span class="keyword">of</span> tipe * tipe</span><br><span class="line">| <span class="type">Pair_t</span> <span class="keyword">of</span> tipe * tipe</span><br><span class="line">| <span class="type">List_t</span> <span class="keyword">of</span> tipe</span><br><span class="line">| <span class="type">Guess_t</span> <span class="keyword">of</span> tipe option <span class="built_in">ref</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tipe_scheme = <span class="type">Forall</span> <span class="keyword">of</span> (tvar <span class="built_in">list</span>) * tipe</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> prim = </span><br><span class="line">  <span class="type">Int</span> <span class="keyword">of</span> <span class="built_in">int</span></span><br><span class="line">| <span class="type">Bool</span> <span class="keyword">of</span> <span class="built_in">bool</span></span><br><span class="line">| <span class="type">Unit</span>   <span class="comment">(* unit value -- () *)</span></span><br><span class="line">| <span class="type">Plus</span>   <span class="comment">(* add two ints *)</span></span><br><span class="line">| <span class="type">Minus</span>  <span class="comment">(* subtract two ints *)</span></span><br><span class="line">| <span class="type">Times</span>  <span class="comment">(* multiply two ints *)</span></span><br><span class="line">| <span class="type">Div</span>    <span class="comment">(* divide two ints *)</span></span><br><span class="line">| <span class="type">Eq</span>     <span class="comment">(* compare two ints for equality *)</span></span><br><span class="line">| <span class="type">Lt</span>     <span class="comment">(* compare two ints for inequality *)</span></span><br><span class="line">| <span class="type">Pair</span>   <span class="comment">(* create a pair from two values *)</span></span><br><span class="line">| <span class="type">Fst</span>    <span class="comment">(* fetch the 1st component of a pair *)</span></span><br><span class="line">| <span class="type">Snd</span>    <span class="comment">(* fetch the 2nd component of a pair *)</span></span><br><span class="line">| <span class="type">Nil</span>    <span class="comment">(* the empty list *)</span></span><br><span class="line">| <span class="type">Cons</span>   <span class="comment">(* create a list from two values *)</span></span><br><span class="line">| <span class="type">IsNil</span>  <span class="comment">(* determine whether a list is Nil *)</span></span><br><span class="line">| <span class="type">Hd</span>     <span class="comment">(* fetch the head of a list *)</span></span><br><span class="line">| <span class="type">Tl</span>     <span class="comment">(* fetch the tail of a list *)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rexp = </span><br><span class="line">  <span class="type">Var</span> <span class="keyword">of</span> var</span><br><span class="line">| <span class="type">PrimApp</span> <span class="keyword">of</span> prim * exp <span class="built_in">list</span></span><br><span class="line">| <span class="type">Fn</span> <span class="keyword">of</span> var * exp</span><br><span class="line">| <span class="type">App</span> <span class="keyword">of</span> exp * exp</span><br><span class="line">| <span class="type">If</span> <span class="keyword">of</span> exp * exp * exp</span><br><span class="line">| <span class="type">Let</span> <span class="keyword">of</span> var * exp * exp</span><br><span class="line"><span class="keyword">and</span> exp = rexp * pos</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>It is not too complicated, but the type inference system is indeed complicated.   </p>
<h2 id="Recursive-Type-Check-Function"><a href="#Recursive-Type-Check-Function" class="headerlink" title="Recursive Type Check Function"></a>Recursive Type Check Function</h2><p>Here is the main entrance of the type inference program:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> tc (env: (var * tipe_scheme) <span class="built_in">list</span>) (e: exp) =</span><br><span class="line">  <span class="comment">(* print_endline (expr2string e);  *)</span></span><br><span class="line">  <span class="keyword">match</span> e <span class="keyword">with</span> </span><br><span class="line">  | <span class="type">Var</span> x, _ -&gt; instantiate (lookup env x)</span><br><span class="line">  | <span class="type">PrimApp</span> (prim, exp_list), _ -&gt; </span><br><span class="line">    (<span class="keyword">match</span> prim, exp_list <span class="keyword">with</span></span><br><span class="line">    | <span class="type">Int</span> <span class="built_in">int</span>, <span class="literal">[]</span> -&gt; <span class="type">Int_t</span></span><br><span class="line">    | <span class="type">Bool</span> <span class="built_in">bool</span>, <span class="literal">[]</span> -&gt; <span class="type">Bool_t</span></span><br><span class="line">    | <span class="type">Unit</span>, <span class="literal">[]</span> -&gt; <span class="type">Unit_t</span></span><br><span class="line">    | <span class="type">Plus</span>, [e1; e2]</span><br><span class="line">    | <span class="type">Minus</span>, [e1; e2]</span><br><span class="line">    | <span class="type">Times</span>, [e1; e2] -&gt;</span><br><span class="line">        <span class="keyword">let</span> t1 = tc env e1 <span class="keyword">in</span></span><br><span class="line">        <span class="comment">(* print_tipe t1; *)</span></span><br><span class="line">        <span class="keyword">let</span> t2 = tc env e2 <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> (unify t1 <span class="type">Int_t</span>) &amp;&amp; (unify t2 <span class="type">Int_t</span>) <span class="keyword">then</span> <span class="type">Int_t</span> <span class="keyword">else</span> type_error <span class="string">&quot;Arithmetic operation failed&quot;</span></span><br><span class="line">    | <span class="type">Eq</span>, [e1; e2] -&gt; </span><br><span class="line">        <span class="keyword">let</span> t1 = tc env e1 <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> t2 = tc env e2 <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> (unify t1 <span class="type">Int_t</span>) &amp;&amp; (unify t2 <span class="type">Int_t</span>) <span class="keyword">then</span> <span class="type">Bool_t</span> <span class="keyword">else</span> type_error <span class="string">&quot;Equality operation failed&quot;</span></span><br><span class="line">    | <span class="type">Lt</span>, [e1; e2] -&gt; </span><br><span class="line">        <span class="keyword">let</span> t1 = tc env e1 <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> t2 = tc env e2 <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> (unify t1 <span class="type">Int_t</span>) &amp;&amp; (unify t2 <span class="type">Int_t</span>) <span class="keyword">then</span> <span class="type">Bool_t</span> <span class="keyword">else</span> type_error <span class="string">&quot;Less than operation failed&quot;</span></span><br><span class="line">    | <span class="type">Fst</span>, [e1] -&gt;</span><br><span class="line">      <span class="keyword">let</span> t1 = tc env e1 <span class="keyword">in</span></span><br><span class="line">      <span class="comment">(* print_tipe t1; *)</span></span><br><span class="line">      (</span><br><span class="line">        <span class="keyword">match</span> t1 <span class="keyword">with</span></span><br><span class="line">          | <span class="type">Pair_t</span> (t, _) -&gt; </span><br><span class="line">            t</span><br><span class="line">          | <span class="type">Guess_t</span> r -&gt; </span><br><span class="line">            (</span><br><span class="line">              <span class="keyword">match</span> !r <span class="keyword">with</span></span><br><span class="line">              | <span class="type">Some</span> <span class="type">Pair_t</span> (t1, t2) -&gt; t1</span><br><span class="line">              | <span class="type">None</span> -&gt;</span><br><span class="line">                <span class="comment">(* print_endline &quot;In Fst guess&quot;; *)</span></span><br><span class="line">                <span class="keyword">let</span> g1 = guess<span class="literal">()</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> g2 = guess<span class="literal">()</span> <span class="keyword">in</span></span><br><span class="line">                r:= <span class="type">Some</span> (<span class="type">Pair_t</span> (g1, g2));</span><br><span class="line">                <span class="comment">(* print_endline &quot;return g1 in Fst guess&quot;; *)</span></span><br><span class="line">                g1</span><br><span class="line">              | _ -&gt; type_error <span class="string">&quot;Fst applied to non-pair, fail in guess&quot;</span></span><br><span class="line">            )</span><br><span class="line">          | _ -&gt; type_error <span class="string">&quot;Fst applied to non-pair&quot;</span></span><br><span class="line">      )</span><br><span class="line">    | <span class="type">Snd</span>, [e1] -&gt;</span><br><span class="line">      <span class="keyword">let</span> t1 = tc env e1 <span class="keyword">in</span></span><br><span class="line">        (</span><br><span class="line">          <span class="keyword">match</span> t1 <span class="keyword">with</span></span><br><span class="line">            | <span class="type">Pair_t</span> (_, t) -&gt; t</span><br><span class="line">            | <span class="type">Guess_t</span> r -&gt; </span><br><span class="line">              (</span><br><span class="line">              <span class="keyword">match</span> !r <span class="keyword">with</span></span><br><span class="line">                | <span class="type">Some</span> <span class="type">Pair_t</span> (t1, t2) -&gt; t2</span><br><span class="line">                | <span class="type">None</span> -&gt;</span><br><span class="line">                  <span class="comment">(* print_endline &quot;In Snd guess&quot;; *)</span></span><br><span class="line">                  <span class="keyword">let</span> g1 = guess<span class="literal">()</span> <span class="keyword">in</span></span><br><span class="line">                  <span class="keyword">let</span> g2 = guess<span class="literal">()</span> <span class="keyword">in</span></span><br><span class="line">                  r:= <span class="type">Some</span> (<span class="type">Pair_t</span> (g1, g2));</span><br><span class="line">                  g2</span><br><span class="line">                | _ -&gt; type_error <span class="string">&quot;Snd applied to non-pair, fail in guess&quot;</span></span><br><span class="line">              )</span><br><span class="line">            | _ -&gt; type_error <span class="string">&quot;Snd applied to non-pair&quot;</span></span><br><span class="line">        )</span><br><span class="line">    | <span class="type">Cons</span>, [e1; e2] -&gt;</span><br><span class="line">      <span class="keyword">let</span> t1 = tc env e1 <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">let</span> t2 = tc env e2 <span class="keyword">in</span></span><br><span class="line">      (</span><br><span class="line">        <span class="keyword">match</span> t2 <span class="keyword">with</span></span><br><span class="line">        | <span class="type">List_t</span> t -&gt; <span class="keyword">if</span> unify t1 t <span class="keyword">then</span> <span class="type">List_t</span> t <span class="keyword">else</span> type_error <span class="string">&quot;Cons type mismatch&quot;</span></span><br><span class="line">        | <span class="type">Guess_t</span> _ -&gt; <span class="type">List_t</span> t1</span><br><span class="line">        | _ -&gt; type_error <span class="string">&quot;Cons applied to non-list&quot;</span></span><br><span class="line">      )</span><br><span class="line">    | <span class="type">Pair</span>, [e1; e2] -&gt;</span><br><span class="line">      <span class="keyword">let</span> t1 = tc env e1 <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">let</span> t2 = tc env e2 <span class="keyword">in</span></span><br><span class="line">      <span class="type">Pair_t</span> (t1, t2)</span><br><span class="line">    | <span class="type">Nil</span>, <span class="literal">[]</span> -&gt; </span><br><span class="line">      <span class="keyword">let</span> g = guess<span class="literal">()</span> <span class="keyword">in</span> <span class="type">List_t</span> g</span><br><span class="line">    | <span class="type">IsNil</span>, [e1] -&gt;</span><br><span class="line">      <span class="keyword">let</span> t1 = tc env e1 <span class="keyword">in</span></span><br><span class="line">      (</span><br><span class="line">        <span class="keyword">match</span> t1 <span class="keyword">with</span></span><br><span class="line">        | <span class="type">List_t</span> _ -&gt; <span class="type">Bool_t</span></span><br><span class="line">        | <span class="type">Guess_t</span> _ -&gt; unify t1 (<span class="type">List_t</span> (guess<span class="literal">()</span>)) ; <span class="type">Bool_t</span></span><br><span class="line">        | _ -&gt; type_error <span class="string">&quot;IsNil applied to non-list&quot;</span></span><br><span class="line">      )</span><br><span class="line">    | <span class="type">Hd</span>, [e1] -&gt;</span><br><span class="line">        <span class="keyword">let</span> t1 = tc env e1 <span class="keyword">in</span></span><br><span class="line">        (<span class="keyword">match</span> t1 <span class="keyword">with</span></span><br><span class="line">        | <span class="type">List_t</span> t -&gt; t</span><br><span class="line">        | <span class="type">Guess_t</span> r -&gt; </span><br><span class="line">          (</span><br><span class="line">            <span class="keyword">match</span> !r <span class="keyword">with</span></span><br><span class="line">              | <span class="type">Some</span> <span class="type">List_t</span> t&#x27;-&gt; t&#x27; </span><br><span class="line">              | <span class="type">Some</span> t&#x27; -&gt; t&#x27;</span><br><span class="line">              | <span class="type">None</span> -&gt; </span><br><span class="line">                <span class="keyword">let</span> g = guess<span class="literal">()</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> unify t1 (<span class="type">List_t</span> g) <span class="keyword">then</span> g <span class="keyword">else</span> type_error <span class="string">&quot;Hd guess failed&quot;</span></span><br><span class="line">          )</span><br><span class="line">        | _ -&gt; type_error <span class="string">&quot;Hd applied to non-list&quot;</span>)</span><br><span class="line">    | <span class="type">Tl</span>, [e1] -&gt;</span><br><span class="line">        <span class="keyword">let</span> t1 = tc env e1 <span class="keyword">in</span></span><br><span class="line">        (<span class="keyword">match</span> t1 <span class="keyword">with</span></span><br><span class="line">        | <span class="type">List_t</span> _ -&gt; t1</span><br><span class="line">        | <span class="type">Guess_t</span> r -&gt; </span><br><span class="line">          (</span><br><span class="line">            <span class="keyword">match</span> !r <span class="keyword">with</span></span><br><span class="line">              | <span class="type">Some</span> t&#x27; -&gt; t&#x27;</span><br><span class="line">              | <span class="type">None</span> -&gt;</span><br><span class="line">                <span class="keyword">let</span> g = guess<span class="literal">()</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> unify t1 (<span class="type">List_t</span> g) <span class="keyword">then</span> (<span class="type">List_t</span> g) <span class="keyword">else</span> type_error <span class="string">&quot;Tl guess failed&quot;</span></span><br><span class="line">          )</span><br><span class="line">        | _ -&gt; type_error <span class="string">&quot;Tl applied to non-list&quot;</span>)</span><br><span class="line">    | _, _ -&gt; type_error <span class="string">&quot;Invalid primitive application&quot;</span>)</span><br><span class="line">  | <span class="type">Fn</span>(x, e), _ -&gt; </span><br><span class="line">    <span class="keyword">let</span> g = guess<span class="literal">()</span> <span class="keyword">in</span></span><br><span class="line">    <span class="type">Fn_t</span> (g, tc ((x, <span class="type">Forall</span>(<span class="literal">[]</span>, g))::env) e)</span><br><span class="line">  | <span class="type">App</span>(e1, e2), _ -&gt;</span><br><span class="line">    <span class="keyword">let</span> t1 = tc env e1 <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> t2 = tc env e2 <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> t = guess<span class="literal">()</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> (unify t1 (<span class="type">Fn_t</span>(t2,t))) <span class="keyword">then</span> t <span class="keyword">else</span> type_error <span class="string">&quot;App failed&quot;</span></span><br><span class="line">  | <span class="type">Let</span>(x, e1, e2), _ -&gt;</span><br><span class="line">    <span class="keyword">let</span> s = generalize env (tc env e1) <span class="keyword">in</span> </span><br><span class="line">    <span class="comment">(* print_endline &quot;finish generalize&quot;; *)</span></span><br><span class="line">    tc ((x, s)::env) e2 </span><br><span class="line">  | <span class="type">If</span> (e1, e2, e3), _ -&gt;</span><br><span class="line">    <span class="keyword">let</span> t1 = tc env e1 <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> t2 = tc env e2 <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> t3 = tc env e3 <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> (unify t1 <span class="type">Bool_t</span>) &amp;&amp; (unify t2 t3) <span class="keyword">then</span> t2 <span class="keyword">else</span> type_error <span class="string">&quot;If failed&quot;</span></span><br></pre></td></tr></table></figure>

<p>This is pretty basic, it is just doing pattern matching for the ast, and recursively call the typecheck program.   </p>
<p>There are several tricky part in the program however, namely Forall, Unify, instantiate and generalize. These are the key functionalities that make up the polymorphism of the Hindley-Milner type system. I will dissect their implementaiton one by one.  </p>
<h2 id="Forall"><a href="#Forall" class="headerlink" title="Forall"></a>Forall</h2><p>Forall is defined in the ast. It is of this type:</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tipe_scheme = <span class="type">Forall</span> <span class="keyword">of</span> (tvar <span class="built_in">list</span>) * tipe</span><br></pre></td></tr></table></figure>
<p>The first part is a list of variables. They are the variables that should be instatiated to fresh guesses when applied as a vairable. The second part is the type after the substitution.  Forall only applied to let expression, when we bound something to a variable, but would like to keep the polymorphism. So instantiate will only happen when type checking a variable.   </p>
<h2 id="Unify"><a href="#Unify" class="headerlink" title="Unify"></a>Unify</h2><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> unify (t1:tipe) (t2:tipe): <span class="built_in">bool</span> =</span><br><span class="line">  <span class="keyword">match</span> t1, t2 <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Guess_t</span> (r1), _ -&gt; (</span><br><span class="line">      <span class="keyword">match</span> !r1 <span class="keyword">with</span></span><br><span class="line">      | <span class="type">Some</span> a&#x27; -&gt; unify a&#x27; t2</span><br><span class="line">      | <span class="type">None</span> -&gt; (</span><br><span class="line">          <span class="keyword">match</span> t2 <span class="keyword">with</span></span><br><span class="line">          | <span class="type">Guess_t</span> (r2) -&gt; (</span><br><span class="line">              <span class="keyword">match</span> !r2 <span class="keyword">with</span></span><br><span class="line">              | <span class="type">None</span> -&gt; (<span class="keyword">if</span> r1 == r2 <span class="keyword">then</span> <span class="literal">true</span> <span class="keyword">else</span> (r1 := <span class="type">Some</span> t2; <span class="literal">true</span>)) <span class="comment">(* t2 also a guess None: check address *)</span></span><br><span class="line">              | <span class="type">Some</span> a&#x27; -&gt; unify t1 a&#x27;</span><br><span class="line">          )</span><br><span class="line">          | _ -&gt; (<span class="keyword">if</span> occurs r1 t2 <span class="keyword">then</span> raise <span class="type">TypeError</span> <span class="keyword">else</span> (r1 := <span class="type">Some</span> t2; <span class="literal">true</span>))</span><br><span class="line">      )</span><br><span class="line">  )</span><br><span class="line">  | _, <span class="type">Guess_t</span>(_) -&gt; unify t2 t1</span><br><span class="line">  | <span class="type">Int_t</span>, <span class="type">Int_t</span> | <span class="type">Bool_t</span>, <span class="type">Bool_t</span> | <span class="type">Unit_t</span>, <span class="type">Unit_t</span> -&gt; <span class="literal">true</span></span><br><span class="line">  | <span class="type">Fn_t</span> (t1a, t1b), <span class="type">Fn_t</span>(t2a, t2b) -&gt;</span><br><span class="line">      (unify t1a t2a) &amp;&amp; (unify t1b t2b)</span><br><span class="line">  | <span class="type">Pair_t</span> (t1a, t1b), <span class="type">Pair_t</span> (t2a, t2b) -&gt;</span><br><span class="line">      (unify t1a t2a) &amp;&amp; (unify t1b t2b)</span><br><span class="line">  | <span class="type">List_t</span> l1, <span class="type">List_t</span> l2 -&gt; unify l1 l2</span><br><span class="line">  | <span class="type">Tvar_t</span> v1, <span class="type">Tvar_t</span> v2 -&gt; (<span class="keyword">if</span> v1 = v2 <span class="keyword">then</span> <span class="literal">true</span> <span class="keyword">else</span> raise <span class="type">TypeError</span>)</span><br><span class="line">  | _, _ -&gt; (raise <span class="type">TypeError</span>)</span><br></pre></td></tr></table></figure>

<p>Unify is very hard to get it working correctly. What it is doing is to resolve guesses. Somewhere during execution, we figure out a reasonable type for a previous guess, and we unify it. It either succeeds or fails. If it fails, then there is a type error, meaning that somewhere in the program the types are not compatible. If it succeeds, then it means the program is potentially legal so far, but we may not always resolve all guesses. A function like fn id: x-&gt;x is essentially unresolvable standalone. Our best effort would be saying that it is of type Fn_t(a’ -&gt; a’). </p>
<p>The part that I tripped on is 1. Occurs and 2. Handling the case of 2 Guess_t None types. </p>
<h3 id="Occurs"><a href="#Occurs" class="headerlink" title="Occurs"></a>Occurs</h3><p>We do not allow recursive types in the Hindley-Milner type system. I think this slide did a good job explaining why. </p>
<p><img src="/images/occurs-type-inference.png"></p>
<p>The answer to the last question in the slide would be it is an indefinitely long sequence. So we want to avoid that. </p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> occurs (r: tipe option <span class="built_in">ref</span>) (t:tipe) : <span class="built_in">bool</span> =</span><br><span class="line">  <span class="keyword">match</span> t <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Guess_t</span> (nr) -&gt; (</span><br><span class="line">      <span class="keyword">match</span> !nr <span class="keyword">with</span></span><br><span class="line">      | <span class="type">Some</span> a&#x27; -&gt; (<span class="keyword">if</span> r == nr <span class="keyword">then</span> <span class="literal">true</span> <span class="keyword">else</span> occurs r a&#x27;)</span><br><span class="line">      | <span class="type">None</span> -&gt; r == nr</span><br><span class="line">  )</span><br><span class="line">  | <span class="type">Int_t</span> | <span class="type">Bool_t</span> | <span class="type">Unit_t</span> -&gt;  <span class="literal">false</span></span><br><span class="line">  | <span class="type">Fn_t</span> (t1, t2) | <span class="type">Pair_t</span> (t1, t2) -&gt; (occurs r t1) || (occurs r t2)</span><br><span class="line">  | <span class="type">List_t</span> l -&gt; occurs r l</span><br><span class="line">  | <span class="type">Tvar_t</span> _ -&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>This situation will only happen when the there are two guesses, and one type has part of it another guess, and that somehow these two types are being unified. It will not happen when the two types are both Guess None: we got that covered in unify. So you want to check that for the first Guess, the reference address of its content is not the same as some part of the second t type (a guess wrapped around in t). And we do the type check recursively. This is a little mind bending right? Understanding occurs is hard, knowing when this happens exactly is harder.   </p>
<h3 id="Unify-2-Guesses"><a href="#Unify-2-Guesses" class="headerlink" title="Unify 2 Guesses"></a>Unify 2 Guesses</h3><p>When I program, there is one test case that I cannot pass, however hard I tried. And it took me the whole afternoon plus evening to locate the cause.  </p>
<p><img src="/images/unify2guesses.png"></p>
<p>Sorry it is a little blurry. I was taking a screenshot because it was so confusing to me. I forgot exactly how I found the cause of the problem, it was a fleeting moment of human intellectuality. But the problem is that when unifying 2 guess None, I treat them as equal and already unified. What we should do is that, check if their reference point to the same location, and if not, then they are not unified. If there are missing the unify step, then you would have the problem that I encountered, which is that the arguements have type (c * d), while the result has type (a * b). They are not unified properly. </p>
<p>So here is the part of the code where this problem is handled:  </p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> unify (t1:tipe) (t2:tipe): <span class="built_in">bool</span> =</span><br><span class="line">  <span class="keyword">match</span> t1, t2 <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Guess_t</span> (r1), _ -&gt; (</span><br><span class="line">      <span class="keyword">match</span> !r1 <span class="keyword">with</span></span><br><span class="line">      | <span class="type">Some</span> a&#x27; -&gt; unify a&#x27; t2</span><br><span class="line">      | <span class="type">None</span> -&gt; (</span><br><span class="line">          <span class="keyword">match</span> t2 <span class="keyword">with</span></span><br><span class="line">          | <span class="type">Guess_t</span> (r2) -&gt; (</span><br><span class="line">              <span class="keyword">match</span> !r2 <span class="keyword">with</span></span><br><span class="line">              | <span class="type">None</span> -&gt; (<span class="keyword">if</span> r1 == r2 <span class="keyword">then</span> <span class="literal">true</span> <span class="keyword">else</span> (r1 := <span class="type">Some</span> t2; <span class="literal">true</span>))</span><br><span class="line">              | <span class="type">Some</span> a&#x27; -&gt; unify t1 a&#x27;</span><br><span class="line">          )</span><br><span class="line">          | _ -&gt; (<span class="keyword">if</span> occurs r1 t2 <span class="keyword">then</span> raise <span class="type">TypeError</span> <span class="keyword">else</span> (r1 := <span class="type">Some</span> t2; <span class="literal">true</span>))</span><br><span class="line">      )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>| None -&gt; (if r1 &#x3D;&#x3D; r2 then true else (r1 :&#x3D; Some t2; true)) This handles the conflict.   </p>
<h2 id="Instantiate"><a href="#Instantiate" class="headerlink" title="Instantiate"></a>Instantiate</h2><p>The instantiate part is relatively straightforward. It replaces all type variables in the Forall’s list with fresh guesses, so that the polymorphism is achieved.  I shall not elaborate on that, since it is easy. (Conceptually easier, but still hard)</p>
<h2 id="Generalize"><a href="#Generalize" class="headerlink" title="Generalize"></a>Generalize</h2><p>This part is mind bending!!! How to do generalize, and why we need to eliminate environment bound variables. It is tricky.   </p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generalize env t =</span><br><span class="line">  <span class="keyword">let</span> t_gs = guesses_of_type t <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> env_lists_vars = <span class="type">List</span>.map guesses_constrained_by_env env <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> env_bound_vars = <span class="type">List</span>.fold_left (<span class="keyword">fun</span> acc gs -&gt; <span class="type">List</span>.append acc gs) <span class="literal">[]</span> env_lists_vars <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> diff = minus t_gs env_bound_vars <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> gs_vs = <span class="type">List</span>.map (<span class="keyword">fun</span> g -&gt; (g, freshvar <span class="literal">()</span>)) diff <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">let</span> tc = subst_guess gs_vs t <span class="keyword">in</span></span><br><span class="line">  <span class="type">Forall</span> (<span class="type">List</span>.map snd gs_vs, tc)</span><br></pre></td></tr></table></figure>

<p>Guess of types gets out all the guesses in the type t. We want to replace them potentially with variable names (forall constructs), so that when they are encountered later, they can be instantiated with fresh guesses, and hence polymorphic. Implementing it is straightforward, if you are careful enough, unlike me. Just extract all guesses. </p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> guesses_of_type t = <span class="keyword">match</span> t <span class="keyword">with</span></span><br><span class="line">  | <span class="type">Tvar_t</span> x -&gt; <span class="literal">[]</span></span><br><span class="line">  | <span class="type">Guess_t</span> r -&gt; </span><br><span class="line">    <span class="keyword">begin</span> <span class="keyword">match</span> !r <span class="keyword">with</span></span><br><span class="line">    | <span class="type">Some</span> t&#x27; -&gt; guesses_of_type t&#x27;</span><br><span class="line">    | <span class="type">None</span> -&gt; </span><br><span class="line">      <span class="comment">(* let new_var = freshvar () in</span></span><br><span class="line"><span class="comment">      r := Some (Tvar_t new_var);  *)</span></span><br><span class="line">      <span class="comment">(* pay attention here, do not return r instead of t *)</span></span><br><span class="line">      [t]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  | <span class="type">Fn_t</span> (t1, t2) | <span class="type">Pair_t</span> (t1, t2) -&gt; <span class="type">List</span>.append (guesses_of_type t1) (guesses_of_type t2)</span><br><span class="line">  | <span class="type">List_t</span> t&#x27; -&gt; guesses_of_type t&#x27;</span><br><span class="line">  | <span class="type">Int_t</span> | <span class="type">Bool_t</span> | <span class="type">Unit_t</span> -&gt; <span class="literal">[]</span></span><br></pre></td></tr></table></figure>

<p>Next we need to take out the environemnt bound guesses. They should not be generalized. To be in the environment, you have to be in the Let clause, and you have to be a forall construct. You may ask, if they are in a forall structure, then they should already be generalized, and then there should be no bare guesses in the tipe part of the Forall construct. That, my friend, is a deep philosophical question. Think about this situation, where you compile a lambda function. The argument become a Forall([], guess_t ref None) in the env. Then it becomes involved in a Pair, say (fn * 1), and now you need to generalize (Guess_t * this pair). You should not generalize the guess for the lambda argument, because you just can’t: it is not part of a Let clause, and is not intended to be polymorphic. It might later be substituted with concrete Guess ref Some tipe. Later, when the argument finally arrives, the guess of the argument will be resolved. Please do not confuse a function with a function in a let clause, like: let thrd &#x3D; fun x -&gt; snd (snd x) in thrd (true, (1, (3 :: nil))). Thrd is indeed intended to be polymorphic.  </p>
<p>So this is the central question of generalize, everything else is conceptually easy. Take the difference of these two sets, replace the guesses with fresh vairables, and returna forall construct. You can check the code yourself. </p>
<p>What an amazing system!</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>[Compiler Construction in Ocaml] Hindley-Milner Type Inference System Implementation</p><p><a href="http://peteryaonyu.github.io/2024/04/07/Compiler-Construction-in-Ocaml-Hindley-Milner-Type-Inference-System-Implementation/">http://peteryaonyu.github.io/2024/04/07/Compiler-Construction-in-Ocaml-Hindley-Milner-Type-Inference-System-Implementation/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Yuncheng Yao</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-04-07</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-04-07</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/01/13/Database-Implementation-of-an-Entendible-Hash-Index/"><span class="level-item">[Database] Implementation of an Entendible Hash Index</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="Yao Yuncheng (Peter)"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Yao Yuncheng (Peter)</p><p class="is-size-6 is-block">yy4108@nyu.edu</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/PeterYaoNYU" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/PeterYaoNYU"><i class="fab fa-github"></i></a></div></div></div><!--!--><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-08T02:25:07.000Z">2024-04-07</time></p><p class="title"><a href="/2024/04/07/Compiler-Construction-in-Ocaml-Hindley-Milner-Type-Inference-System-Implementation/">[Compiler Construction in Ocaml] Hindley-Milner Type Inference System Implementation</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-14T03:36:41.000Z">2024-01-13</time></p><p class="title"><a href="/2024/01/13/Database-Implementation-of-an-Entendible-Hash-Index/">[Database] Implementation of an Entendible Hash Index</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-12T09:12:17.000Z">2024-01-12</time></p><p class="title"><a href="/2024/01/12/Consensus-Raft-from-Scratch-Leader-Election/">[Consensus] Raft from Scratch: Leader Election</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-09T04:21:48.000Z">2024-01-08</time></p><p class="title"><a href="/2024/01/08/Implementing-a-MapReduce-Framework-with-Golang-from-scratch/">Implementing a MapReduce Framework with Golang RPC from scratch</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-19T00:18:38.000Z">2023-12-18</time></p><p class="title"><a href="/2023/12/18/Database-Bustub-Buffer-Pool-Manager-Implementation/">[Database] Bustub Buffer Pool Manager Implementation</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Database-Systems/"><span class="tag">Database Systems</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Distribute-Systems/"><span class="tag">Distribute Systems</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-Systems/"><span class="tag">Operating Systems</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Yao Yuncheng(Peter)</a><p class="is-size-7"><span>&copy; 2024 Yuncheng Yao</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PeterYaoNYU"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>