<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>[Database] Implementation of an Entendible Hash Index - Peter Yuncheng Yao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Peter&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Peter&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="This blog documents how I went about implementing an exntendible hash index for a database, from scratch in modern C++. Hash table sits in the core of many ascpects of a database, from building index"><meta property="og:type" content="blog"><meta property="og:title" content="[Database] Implementation of an Entendible Hash Index"><meta property="og:url" content="http://peteryaonyu.github.io/2024/01/13/Database-Implementation-of-an-Entendible-Hash-Index/"><meta property="og:site_name" content="Peter Yuncheng Yao"><meta property="og:description" content="This blog documents how I went about implementing an exntendible hash index for a database, from scratch in modern C++. Hash table sits in the core of many ascpects of a database, from building index"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://peteryaonyu.github.io/img/og_image.png"><meta property="article:published_time" content="2024-01-13T14:36:41.000Z"><meta property="article:modified_time" content="2024-01-19T14:27:26.704Z"><meta property="article:author" content="Yuncheng Yao"><meta property="article:tag" content="Database Systems"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://peteryaonyu.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://peteryaonyu.github.io/2024/01/13/Database-Implementation-of-an-Entendible-Hash-Index/"},"headline":"[Database] Implementation of an Entendible Hash Index","image":["http://peteryaonyu.github.io/img/og_image.png"],"datePublished":"2024-01-13T14:36:41.000Z","dateModified":"2024-01-19T14:27:26.704Z","author":{"@type":"Person","name":"Yuncheng Yao"},"publisher":{"@type":"Organization","name":"Peter Yuncheng Yao","logo":{"@type":"ImageObject","url":{"text":"Yao Yuncheng(Peter)"}}},"description":"This blog documents how I went about implementing an exntendible hash index for a database, from scratch in modern C++. Hash table sits in the core of many ascpects of a database, from building index"}</script><link rel="canonical" href="http://peteryaonyu.github.io/2024/01/13/Database-Implementation-of-an-Entendible-Hash-Index/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Peter Yuncheng Yao" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Yao Yuncheng(Peter)</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PeterYaoNYU"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-01-13T14:36:41.000Z" title="1/13/2024, 10:36:41 PM">2024-01-13</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-01-19T14:27:26.704Z" title="1/19/2024, 10:27:26 PM">2024-01-19</time></span><span class="level-item">12 minutes read (About 1800 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">[Database] Implementation of an Entendible Hash Index</h1><div class="content"><p>This blog documents how I went about implementing an exntendible hash index for a database, from scratch in modern C++. Hash table sits in the core of many ascpects of a database, from building index for fast lookup to effecient implementation of the hash join executor. </p>
<p>Per CMU policy, Bustub solution should not be made public. Hence, only code snippets and basic logic are shown here. If you need to see the code for a specific reason, email me: <a href="mailto:&#x79;&#x79;&#x34;&#49;&#48;&#56;&#x40;&#110;&#x79;&#x75;&#x2e;&#x65;&#x64;&#117;">&#x79;&#x79;&#x34;&#49;&#48;&#56;&#x40;&#110;&#x79;&#x75;&#x2e;&#x65;&#x64;&#117;</a>.</p>
<span id="more"></span>

<p>I am again on a trip, but this time alone. I am waiting for my plane to Changsha. With nothing better to do now, let’s try to stay productive. </p>
<p>I believe that building a hash index is significantly easier than building a B+ tree index. Nevertheless, it takes considerable effort to get it work correctly. The main challenge would be implementing the grow and shrink function of the hash table, and understanding what “extendible” really means. </p>
<h2 id="RAII-Read-Write-Page-Guards"><a href="#RAII-Read-Write-Page-Guards" class="headerlink" title="RAII Read&#x2F;Write Page Guards"></a>RAII Read&#x2F;Write Page Guards</h2><p>One difficulty when I tried to implement the B+ tree index is that I always forget to unpin&#x2F;unlatch a page after use. Forget to unlatch a page will cause correctness issue, including a deadlock potentially. Forgetting to unpin a page will cause performance degradation, as less pages can be swapped in. We will effectively have a much smaller buffer pool when we forget to unpin: the buffer pool manager cannot swap out the unused pages anymore. </p>
<p>To mitgate this issue, we need to take advantage of the RAII feature of modern C++. We want to make sure that once a page goes out scope of usage, it is automatically unpinned&#x2F;unlatched. </p>
<p>Let’s first implement a basic page guard, and later we will extend it to a Read Page Guard and a Write Page Guard, by holding extra read&#x2F;write latches. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicPageGuard</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BasicPageGuard</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">BasicPageGuard</span>(BufferPoolManager *bpm, Page *page) : <span class="built_in">bpm_</span>(bpm), <span class="built_in">page_</span>(page) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">BasicPageGuard</span>(<span class="type">const</span> BasicPageGuard &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">operator</span>=(<span class="type">const</span> BasicPageGuard &amp;) -&gt; BasicPageGuard &amp; = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>

<p>In the header, we can see that the BasicPageGuard has the default constructor and an easy customized constructor. The copy constructor and assignment operator have been deleted: now that we are implementing an RAII-style class, enabling the copy constructor will cause additional troubles, rendering the RAII semantics useless. RAII objects can only be <em>moved</em>, but not <em>copied</em>. </p>
<p>Now let’s talk about how to enable the move semantics in the page guard class. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">BasicPageGuard::<span class="built_in">BasicPageGuard</span>(BasicPageGuard &amp;&amp;that) <span class="keyword">noexcept</span></span><br><span class="line">    : <span class="built_in">bpm_</span>(that.bpm_), <span class="built_in">page_</span>(that.page_), <span class="built_in">is_dirty_</span>(that.is_dirty_) &#123;</span><br><span class="line">  that.bpm_ = <span class="literal">nullptr</span>;</span><br><span class="line">  that.page_ = <span class="literal">nullptr</span>;</span><br><span class="line">  that.is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> BasicPageGuard::<span class="keyword">operator</span>=(BasicPageGuard &amp;&amp;that) <span class="keyword">noexcept</span> -&gt; BasicPageGuard &amp; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;that) &#123;</span><br><span class="line">    <span class="built_in">Drop</span>();</span><br><span class="line">    <span class="comment">// Transfer ownership</span></span><br><span class="line">    bpm_ = that.bpm_;</span><br><span class="line">    page_ = that.page_;</span><br><span class="line">    is_dirty_ = that.is_dirty_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invalidate the moved-from object</span></span><br><span class="line">    that.bpm_ = <span class="literal">nullptr</span>;</span><br><span class="line">    that.page_ = <span class="literal">nullptr</span>;</span><br><span class="line">    that.is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BasicPageGuard::Drop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (page_ != <span class="literal">nullptr</span> &amp;&amp; bpm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    bpm_-&gt;<span class="built_in">UnpinPage</span>(page_-&gt;<span class="built_in">GetPageId</span>(), is_dirty_);</span><br><span class="line">  &#125;</span><br><span class="line">  bpm_ = <span class="literal">nullptr</span>;</span><br><span class="line">  page_ = <span class="literal">nullptr</span>;</span><br><span class="line">  is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BasicPageGuard::~<span class="built_in">BasicPageGuard</span>() &#123; <span class="built_in">Drop</span>(); &#125;;  <span class="comment">// NOLINT</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>The most important thing when we are implementing move semantics is that we have to make sure that the original object is no longer usable. We need to make sure that the parameter’s attirbutes are changed to nullptr, so that we can no longer access the moved object via the original reference. </p>
<p>Similar procedure is undertaken when impelenting the assignmet move operator. Apart from changing the moved object’s attributes to nullptr, we also need to make sure that the object <em>this</em> is pointing to is deallocated effectively, which, in the context of page, <em>dropped</em>, as we can see from the implementation of the destructor. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ReadPageGuard::<span class="built_in">ReadPageGuard</span>(ReadPageGuard &amp;&amp;that) <span class="keyword">noexcept</span> : <span class="built_in">guard_</span>(std::<span class="built_in">move</span>(that.guard_))&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ReadPageGuard::<span class="keyword">operator</span>=(ReadPageGuard &amp;&amp;that) <span class="keyword">noexcept</span> -&gt; ReadPageGuard &amp; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;that) &#123;</span><br><span class="line">    <span class="built_in">Drop</span>();</span><br><span class="line">    guard_ = std::<span class="built_in">move</span>(that.guard_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadPageGuard::Drop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (guard_.page_ != <span class="literal">nullptr</span> &amp;&amp; guard_.bpm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    guard_.page_-&gt;<span class="built_in">RUnlatch</span>();</span><br><span class="line">    guard_.<span class="built_in">Drop</span>();</span><br><span class="line">    guard_.page_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReadPageGuard::~<span class="built_in">ReadPageGuard</span>() &#123; <span class="built_in">Drop</span>(); &#125;  <span class="comment">// NOLINT</span></span><br></pre></td></tr></table></figure>

<p>The implementation of a basic page guard can be easily extended to a ReadPageGuard and a WritePageGuard. The only thing we need to pay attention to is that when we are dropping a read page and a write page, we need to unlatch the page itself. Here I only include the ReadPage, WritePage is very similar. The page should be automatically dropped when the page goes out of scope.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BasicPageGuard::UpgradeRead</span><span class="params">()</span> -&gt; ReadPageGuard </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (page_ == <span class="literal">nullptr</span> || bpm_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Cannot upgrade a BasicPageGuard that does not guard any page.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">ReadPageGuard <span class="title">read_guard</span><span class="params">(bpm_, page_)</span></span>;</span><br><span class="line">  page_-&gt;<span class="built_in">RLatch</span>();</span><br><span class="line"></span><br><span class="line">  bpm_ = <span class="literal">nullptr</span>;</span><br><span class="line">  page_ = <span class="literal">nullptr</span>;</span><br><span class="line">  is_dirty_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read_guard;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BasicPageGuard::UpgradeWrite</span><span class="params">()</span> -&gt; WritePageGuard </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (page_ == <span class="literal">nullptr</span> || bpm_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Cannot upgrade a BasicPageGuard that does not guard any page.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">WritePageGuard <span class="title">write_guard</span><span class="params">(bpm_, page_)</span></span>;</span><br><span class="line"></span><br><span class="line">  page_-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line"></span><br><span class="line">  bpm_ = <span class="literal">nullptr</span>;</span><br><span class="line">  page_ = <span class="literal">nullptr</span>;</span><br><span class="line">  is_dirty_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> write_guard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When we are upgrading a basic page to one that can read&#x2F;write, we create a new ReadPageGuard&#x2F;WritePageGuard, make the basic page’s attributes NULL, and take on the corresponding read&#x2F;write latch. The logic is very similar for both Read and Write pages. </p>
<p>Now that we have implemented the page guard, we can update the buffer pool manager. We can now fetch page using the new page guard. This way the page should be automatically dropped when the page goes out of scope. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageBasic</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; BasicPageGuard </span>&#123;</span><br><span class="line">  Page *fetched_page = <span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="keyword">this</span>, fetched_page&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageRead</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; ReadPageGuard </span>&#123;</span><br><span class="line">  Page *fetched_page = <span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">  fetched_page-&gt;<span class="built_in">RLatch</span>();</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="keyword">this</span>, fetched_page&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPageWrite</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; WritePageGuard </span>&#123;</span><br><span class="line">  Page *fetched_page = <span class="built_in">FetchPage</span>(page_id);</span><br><span class="line">  fetched_page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="keyword">this</span>, fetched_page&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::NewPageGuarded</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> -&gt; BasicPageGuard </span>&#123;</span><br><span class="line">  Page *new_page = <span class="built_in">NewPage</span>(page_id);</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="keyword">this</span>, new_page&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This part should be relatively easy. Just fetch the page&#x2F;new a page, take the corresponding read&#x2F;write lock if necessary, and return a constructed page guard. </p>
<h2 id="Extendible-Hash-Table-Pages"><a href="#Extendible-Hash-Table-Pages" class="headerlink" title="Extendible Hash Table Pages"></a>Extendible Hash Table Pages</h2><p>Now that I am back to Shanghai, my flight to New York will be tomorrow. It is with some trepidation that I set feet on the dangerous soil of NYC. I am too worried to do anything else, so let us document what we have accomplished. The rule is similar, for Bustub, ***only basic logic is shown, in accordance with the open source agreement. Full code will not be provided, only high level idea. My repo is private. If you want to see the code, email me with a reason. ***</p>
<p>Before go on and start implementing the extendible hash table algorithm, we need to first define hash table pages. There are 3 types of hash table pages we need to define:</p>
<ul>
<li>Hash table header page</li>
<li>hash table directory page</li>
<li>hash table bucket page</li>
</ul>
<h3 id="How-extendible-hash-table-works"><a href="#How-extendible-hash-table-works" class="headerlink" title="How extendible hash table works?"></a>How extendible hash table works?</h3><p>These three page types form a hierarchy of look-up. When a look up key is needed, we first hash it, looking through the header page and find the corresponding directory page with the hash value. Then, using the value we found in the directory page (again with the hashed value of the given key), we go into the corresponding bucket page. With a linear scan (or sth smarter than that) of the bucket page, which is the page storing the actual page reference, we will be able to locate the actual page that store the data we want. </p>
<p>The most challengin part should not be defining the pages, but rather the growing and shrinking of the directory page table. So for this part, it is still relatively easy.</p>
<h3 id="Header-Page"><a href="#Header-Page" class="headerlink" title="Header Page"></a>Header Page</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtendibleHTableHeaderPage::Init</span><span class="params">(<span class="type">uint32_t</span> max_depth)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// throw NotImplementedException(&quot;ExtendibleHTableHeaderPage is not implemented&quot;);</span></span><br><span class="line">  max_depth_ = max_depth;</span><br><span class="line">  <span class="built_in">memset</span>(directory_page_ids_, <span class="number">0xff</span>, <span class="built_in">sizeof</span>(directory_page_ids_));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ExtendibleHTableHeaderPage::HashToDirectoryIndex</span><span class="params">(<span class="type">uint32_t</span> hash)</span> <span class="type">const</span> -&gt; <span class="type">uint32_t</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (max_depth_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint32_t</span> shift = <span class="number">32</span> - max_depth_;</span><br><span class="line">  <span class="type">uint32_t</span> directory_index = hash &gt;&gt; shift;</span><br><span class="line">  <span class="comment">// printf(&quot;hash: %d, shift: %d, directory_index: %d, max_depth: %d\n&quot;, hash, shift, directory_index, max_depth_);</span></span><br><span class="line">  <span class="keyword">return</span> directory_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ExtendibleHTableHeaderPage::GetDirectoryPageId</span><span class="params">(<span class="type">uint32_t</span> directory_idx)</span> <span class="type">const</span> -&gt; <span class="type">uint32_t</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> directory_page_ids_[directory_idx];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtendibleHTableHeaderPage::SetDirectoryPageId</span><span class="params">(<span class="type">uint32_t</span> directory_idx, <span class="type">page_id_t</span> directory_page_id)</span> </span>&#123;</span><br><span class="line">  directory_page_ids_[directory_idx] = directory_page_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ExtendibleHTableHeaderPage::MaxSize</span><span class="params">()</span> <span class="type">const</span> -&gt; <span class="type">uint32_t</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; max_depth_; &#125;</span><br></pre></td></tr></table></figure>

<p>The implementation, as I said, should be naive. Above, I provide a high level idea. We use the biggest bits (top bits) to determine the directory page we need. After getting the idx, we use a simple vector to fetch the corresponding page id. Later when we use this code, we follow these steps:</p>
<ol>
<li>call the hash function to get the hash value of the key</li>
<li>call HashToDirectoryIndex() to get the directory idx</li>
<li>call GetDirectoryPageId() to get the page id of the directory page</li>
<li>Use the buffer pool manager we have implemented before to fetch the actual directory page</li>
<li>Repeat a very similar process within the directory page</li>
</ol>
<hr>
<h3 id="Directory-Page"><a href="#Directory-Page" class="headerlink" title="Directory Page"></a>Directory Page</h3><p>The directory page is a little bit more complex. We need to take shrinking and growing into consideration now. We now have a global depth and an array of local depth. Let’s differentiate their usage below</p>
<blockquote>
<p>Global depth is used to find the bucket page. We use the global depth as a mask, when masking the hash value, we can find the corresponding bucket page we need. </p>
</blockquote>
<p>Here is an example of the usage of global depth. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ExtendibleHTableDirectoryPage::HashToBucketIndex</span><span class="params">(<span class="type">uint32_t</span> hash)</span> <span class="type">const</span> -&gt; <span class="type">uint32_t</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> mask = (<span class="number">1</span> &lt;&lt; global_depth_) - <span class="number">1</span>;</span><br><span class="line">  <span class="type">uint32_t</span> bucket_index = hash &amp; mask;</span><br><span class="line">  <span class="keyword">return</span> bucket_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Local depth is the specific depth of a certain page. When the page is full, we need to increment the local depth. If all local depths are incremented, we need to update the global depth. Local depth is responsible for the extendibility of the hash table. When hash table becomes full, increment local depth to grow. Conversly, decrement to shrink. </p>
</blockquote>
<p>Here is how local depth is used in the directory page. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ExtendibleHTableDirectoryPage::GetSplitImageIndex</span><span class="params">(<span class="type">uint32_t</span> bucket_idx)</span> <span class="type">const</span> -&gt; <span class="type">uint32_t</span> </span>&#123;</span><br><span class="line">  <span class="type">uint8_t</span> local_depth = local_depths_[bucket_idx];</span><br><span class="line">  <span class="type">uint32_t</span> depth_bit = <span class="number">1</span> &lt;&lt; (local_depth - <span class="number">1</span>);</span><br><span class="line">  <span class="type">uint32_t</span> split_image_index = (bucket_idx ^ depth_bit) &amp; ((<span class="number">1</span> &lt;&lt; global_depth_) - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> split_image_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExtendibleHTableDirectoryPage::IncrGlobalDepth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (global_depth_ &gt;= max_depth_) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; global_depth_); i++) &#123;</span><br><span class="line">    bucket_page_ids_[(<span class="number">1</span> &lt;&lt; global_depth_) + i] = bucket_page_ids_[i];</span><br><span class="line">    local_depths_[(<span class="number">1</span> &lt;&lt; global_depth_) + i] = local_depths_[i];</span><br><span class="line">  &#125;</span><br><span class="line">  global_depth_++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ExtendibleHTableDirectoryPage::CanShrink</span><span class="params">()</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="type">uint32_t</span> num_buckets = <span class="number">1</span> &lt;&lt; global_depth_;</span><br><span class="line">  <span class="type">bool</span> can_shrink = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; num_buckets; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (local_depths_[i] == global_depth_) &#123;</span><br><span class="line">      can_shrink = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> can_shrink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There are more, but here, we only focus on the high level idea. </p>
<hr>
<p>Bucket Page</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>[Database] Implementation of an Entendible Hash Index</p><p><a href="http://peteryaonyu.github.io/2024/01/13/Database-Implementation-of-an-Entendible-Hash-Index/">http://peteryaonyu.github.io/2024/01/13/Database-Implementation-of-an-Entendible-Hash-Index/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Yuncheng Yao</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-01-13</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-01-19</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Database-Systems/">Database Systems</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/01/12/Consensus-Raft-from-Scratch-Leader-Election/"><span class="level-item">[Consensus] Raft from Scratch: Leader Election</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="Yao Yuncheng (Peter)"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Yao Yuncheng (Peter)</p><p class="is-size-6 is-block">yy4108@nyu.edu</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/PeterYaoNYU" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/PeterYaoNYU"><i class="fab fa-github"></i></a></div></div></div><!--!--><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-13T14:36:41.000Z">2024-01-13</time></p><p class="title"><a href="/2024/01/13/Database-Implementation-of-an-Entendible-Hash-Index/">[Database] Implementation of an Entendible Hash Index</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-12T09:12:17.000Z">2024-01-12</time></p><p class="title"><a href="/2024/01/12/Consensus-Raft-from-Scratch-Leader-Election/">[Consensus] Raft from Scratch: Leader Election</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-09T04:21:48.000Z">2024-01-09</time></p><p class="title"><a href="/2024/01/09/Implementing-a-MapReduce-Framework-with-Golang-from-scratch/">Implementing a MapReduce Framework with Golang RPC from scratch</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-19T00:18:38.000Z">2023-12-19</time></p><p class="title"><a href="/2023/12/19/Database-Bustub-Buffer-Pool-Manager-Implementation/">[Database] Bustub Buffer Pool Manager Implementation</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-07-10T13:48:33.000Z">2023-07-10</time></p><p class="title"><a href="/2023/07/10/cmu15-213-attack-lab/">CMU15-213 Attack Lab</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Database-Systems/"><span class="tag">Database Systems</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Distribute-Systems/"><span class="tag">Distribute Systems</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-Systems/"><span class="tag">Operating Systems</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Yao Yuncheng(Peter)</a><p class="is-size-7"><span>&copy; 2024 Yuncheng Yao</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PeterYaoNYU"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>