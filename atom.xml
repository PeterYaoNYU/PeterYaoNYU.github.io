<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-15T13:45:15.400Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMU15-213 Attack Lab</title>
    <link href="http://example.com/2023/07/10/cmu15-213-attack-lab/"/>
    <id>http://example.com/2023/07/10/cmu15-213-attack-lab/</id>
    <published>2023-07-10T13:48:33.000Z</published>
    <updated>2023-12-15T13:45:15.400Z</updated>
    
    <content type="html"><![CDATA[<p>It’s been a while since I wrote posts about CMU’s renowned system course 15-213. Last month, I was primarily devoted to my research on SmartNICs and ML for failure detection, and traveling. </p><p>Let’s begin phase by phase.</p><p>Logistics</p><p>The writeup of this lab can be found <a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">here</a> (the CS:APP website). You can <a href="/images/attacklab.pdf">download it from this blog</a> as well.</p><p>The target file can be downloaded from my website as well. Open that using linux tar, or you may change the permissions of the file.</p><p><a href="/images/target1.tar">target1</a><a href="/images/target1.tar">Download</a></p><p>According to my experience, this lab does not work on virtual machines. Bare metal Ubuntu is preferred. I use NYU server instead. </p><p><img src="/images/Screenshot-2023-07-10-at-21.50.11-1024x681.png">Not working on my multi-tenant cloud server</p><p><img src="/images/Screenshot-2023-07-10-at-21.52.03-1024x681.png">Working on NYU bare metal Ubuntu20 server</p><p>Non-CMU student, when running the code, should add a <em><strong>-q</strong></em> flag, so that the program will not try to contact the grading service and then failed. </p><p><strong>Phase 1: Simple Buffer Overflow Attack</strong></p><p>Phase 1 is a very simple buffer overflow attack, and its main idea was went through during the lecture. </p><p>First use <em><strong>objdump -d</strong></em> to get the disassembled file, can be .txt or .asm. Then check the disas file. </p><p><img src="/images/Screenshot-2023-07-10-at-21.56.46-1024x591.png"></p><p>Use Vim to search for <test>, we find the main logic of phase 1. It calls <getbuf> and then returns. We want to change the return address so that when the execution returns from <getbuf>, it will be redirected to the <touch1> function.</p><p><img src="/images/Screenshot-2023-07-10-at-22.00.24-1024x591.png"><touch1> function has an address of 0x00 00 00 00 00 40 17 c0, and we want to jump to it. </p><p>To inject the malicious return address, we first need to know how much buffer the <getbuf> function has allocated. I suggest that you take <em><strong>GDB</strong></em> as your most loyal friend. </p><p><img src="/images/Screenshot-2023-07-10-at-22.05.32-1024x591.png"></p><p><strong>Ok, so the <getbuf> allocated 0x28 bytes, which in decimal is 40 bytes. So we first need to fill the 40 bytes buffer with random input, and then the address of the desired function. Remember that the <getbuf> function fills the stack from the smaller address to the bigger one. So it starts filling from the lower right corner to the upper left corner. However, when the program is reading the return address, it reads from the bigger address to the smaller one (reverse direction). With that being said, the injection string could look something like this:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">c0 17 40 00</span><br><span class="line">00 00 00 00</span><br></pre></td></tr></table></figure><p><img src="/images/Screenshot-2023-07-10-at-22.14.35-1024x591.png"></p><p>Try it, works as expected.</p><p><strong>Phase 2: Code injection</strong></p><p>This level is a lot more interesting, I have got to say. The biggest challenge for me is to recall the fact that stack grows downwards (from bigger virtual addresses to smaller ones), while the binary code is executed bottom up (from smaller virtual addresses to bigger ones). So remember that in phase 1 we need to reverse the order of out input so that the malicious return address is in the correct order? In this phase, now that we are directly injecting malicious code, we do not need to reverse the order of the code, since they are executed bottom up, in accordance with the order that <getbuf> gets the input from the user, which is also bottom up. However, we still need to reverse the order of the intended virtual addresses, since the input order is the opposite of the way return address is read by the operating system. </p><p>Forgive me for speaking too much without giving you an idea what we are doing here. </p><p><img src="/images/Screenshot-2023-07-11-at-11.22.44-1024x921.png"></p><p>In this level, we need to redirect the return address of the program to <touch2> but at the same time change the first parameter register %rdi to have value in our cookie.txt, which in our case has the value:</p><p><img src="/images/Screenshot-2023-07-11-at-11.24.29-1024x94.png"></p><p>Sounds challenging, right?</p><p>The basic idea is that: first we need to change the return address after the <getbuf> procedure to somewhere on the stack (in this question, stack execution protection is disabled), that somewhere should be the place where we input our malicious code, which is the 40 bytes buffer of the <getbuf> function. For convenience, I will just set the return address to the bottom of the stack when the <getbuf> is called, namely the start of the 40 bytes buffer. </p><p>Then we need to think about what code we would like to put in the stack we were given. I propose something like this, in assembly of course:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $0x5561dc98, %rdi</span><br><span class="line">pushq $0x000000004017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>The first line puts the cookie into the register that holds the parameter value for procedure <touch2>. The second line push a return address to the stack, and pushq command will also automatically decrement the stack pointer by 8, so that when we execute ret command in the third line, the stack pointer will increment by 8 automatically, and pop the return address out. This 0x4017ec address points to the <touch2> procedure, which can be found out here:</p><p><img src="/images/Screenshot-2023-07-11-at-11.36.16-1024x591.png"></p><p>The last piece of this puzzle is, what should the return address of the <getbuf> function be changed to? We want to change it to the beginning of our malicious injected code, which we inject starting at the lowest address of the 40 byte buffer. The answer is self-evident, we need to change the return address to the lowest address of the buffer, and the code will be then executed from bottom up. </p><p>So what is this lowest address? I suggest GDB again, your most faithful friend with Linux. </p><p><img src="/images/Screenshot-2023-07-11-at-11.41.42-1024x591.png"></p><p>The answer is here, 0x5561dc78!</p><p>One last step before putting everything together. What is the binary representation of the assembly that we are injecting? To find out, first compile this assembly, and then objdump -d the output to find out. </p><p><img src="/images/Screenshot-2023-07-11-at-11.44.15-1024x591.png"></p><p>Putting everything together, here is what we should input </p><p><img src="/images/Screenshot-2023-07-16-at-13.59.03-1024x591.png"></p><p><img src="/images/Screenshot-2023-07-16-at-14.01.33-1024x591.png">this is indeed a valid answer for level 2 of the lab.</p><p><strong>Phase 3: Advanced Code Injection</strong></p><p>This phase is quite formidable, I have got to admit. Let’s first check out the requirement of the question, it gives us a lot of useful hints.</p><p><img src="/images/Screenshot-2023-07-16-at-16.59.03-1024x455.png"></p><p><img src="/images/Screenshot-2023-07-16-at-16.59.11-1024x777.png"></p><p>The code snippet is not entirely easy to understand, because it does seem a little bit whimsical. If you were able to break down the requirement, here is what we need to do:</p><ol start="2"><li><p>jump to <touch3>, which is at address 0x4018fa of the virtual address space</p></li><li><p>pass the address of the ASCII representation of our cookie to register %rdi, which serves as a parameter when we call the procedure <hexmatch>.</p></li><li><p>Figure out a safe place within the stack to store the ASCII representation of our cookie, because some portion of the stack may be overwritten by the the code from <hexmatch></p></li></ol><p>It is observable that we first need to figure out (3), i.e. a safe place that will not be overwritten, then figure out the code we inject to the buffer. </p><p>So what is the ASCII representation of the cookie, which for us is 0x59b997fa? How many bytes of space do we need to store the ASCII representation of it?</p><p><img src="/images/Screenshot-2023-07-16-at-17.09.59-1024x339.png"></p><p>It seems that we need 8 bytes of space, and the ASCII code is 35 39 62 39 39 37 66 61.</p><p>So which place is safe to store these 8 bytes? In other words, which part of the stack will be overwritten when we call <hexmatch>? GDB will tell us. </p><p><img src="/images/Screenshot-2023-07-16-at-17.15.42-1024x653.png"></p><p>First, try this input, then check how much of the 11111…1111 buffer space is changed by hexmatch in GDB. The return address is changed by buffer overflow to <touch3> so that we can observe the behavior of <hexmatch>. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># convert hex to raw hex</span><br><span class="line">./hex2raw &lt; p3\_test.txt &gt; p3\_test\_raw.txt</span><br><span class="line"># GDB COMMAND</span><br><span class="line">gdb --args ./ctarget -q</span><br><span class="line">b test</span><br><span class="line">run -q &lt; p3\_test\_raw.txt</span><br><span class="line"># inspect the first 80 bytes starting at a certain address, in hex</span><br><span class="line">x/20x 0x5561dc78</span><br></pre></td></tr></table></figure><p><img src="/images/Screenshot-2023-07-16-at-17.27.08-1024x653.png"></p><p>now that we are in <touch3>, make a breakpoint before and after <hexmatch> to see how much of the buffer has been changed. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b \*0x040190b</span><br><span class="line">(gdb) b \*0x0401916</span><br></pre></td></tr></table></figure><p><img src="/images/Screenshot-2023-07-16-at-17.28.52-1024x177.png">this is the buffer layout before calling <hexmatch></p><p><img src="/images/Screenshot-2023-07-16-at-17.30.37-1024x185.png">this is the buffer layout after calling <hexmatch></p><p>we can see that all 40 bytes have been overwritten. So we have to buffer overflow more, and store the address of the ASCII code at someplace after. Address starting at 0x5561dca8 seems unchanged after calling <hexmatch>, and is thus a valid candidate. </p><p>So we want to overflow more than the typical 48 bytes. We want at least 56 bytes, and the last 8 bytes are for the ASCII.</p><p>Then we need to translate the code using the same technique: write the code, gcc -c, objdump -d</p><p><img src="/images/Screenshot-2023-07-16-at-17.37.40-1024x653.png"></p><p>You see that we store the address of the ASCII to $rdi, change the return address to <touch3> and then return. </p><p>We put the code at the beginning of the buffer, so the return address of <getbuf> should also be changed to 0x5561dc78</p><p>Putting everything together, here is the injection code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8</span><br><span class="line">dc 61 55 68</span><br><span class="line">fa 18 40 00</span><br><span class="line">c3 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">00 00 00 00</span><br><span class="line">78 dc 61 55</span><br><span class="line">00 00 00 00</span><br><span class="line">35 39 62 39</span><br><span class="line">39 37 66 61</span><br></pre></td></tr></table></figure><p><img src="/images/Screenshot-2023-07-16-at-17.40.17-1024x653.png"></p><p>test it, it is indeed the answer. </p><p><img src="/images/Screenshot-2023-07-16-at-18.10.25-1024x653.png"></p><p><strong>Phase 4: Return-Oriented Attacks</strong></p><p>This phase is quite easy, takes around 20 minutes to solve (the previous phase takes me hours…)</p><p>The key idea is to understand how to use return-oriented programming to inject malicious code. I think that the lab write-up did a pretty decent job, so let me just quote here. </p><p><img src="/images/Screenshot-2023-07-16-at-19.24.57-1024x457.png"></p><p><img src="/images/Screenshot-2023-07-16-at-19.25.17-819x1024.png"></p><p>The main difficulty then is to find the appropriate code segments and piece them together. </p><p><img src="/images/Screenshot-2023-07-16-at-19.26.24-1024x581.png"></p><p>here is the requirement for this phase. If you are logical enough, here is the stuff that we need to do:</p><ol start="2"><li><p>use popq instruction to put the cookie to %rdi</p></li><li><p>then jump to the procedure <touch2></p></li></ol><p><img src="/images/Screenshot-2023-07-16-at-19.29.16-1024x453.png"></p><p>As hinted by the author, here we only use popq and movq. Two gadgets are enough. Now let us take a look at the gadgets available!</p><p><img src="/images/Screenshot-2023-07-16-at-19.30.28-1024x653.png"></p><p><img src="/images/Screenshot-2023-07-16-at-19.30.57-1024x653.png"></p><p>We can only use the first 8 gadgets, from the &lt;start_farm&gt; to the &lt;mid_farm&gt;. Apparently, we need a popq to pop the cookie to a certain register, so we are looking for anything from 58 to 5f.</p><p>You can choose either &lt;getval_280&gt; or &lt;addval_219&gt;, which contains </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">58 90 c3 </span><br><span class="line">// popq %rax</span><br></pre></td></tr></table></figure><p>Note that there is no 5f in the code snippet farm, so we cannot pop directly to %rdi. We can however, later move the content from %rax to %rdi. So we are looking for 48 89 c7. &lt;setval_426&gt; provide the segment for that. </p><p>I choose &lt;getval_280&gt; and &lt;setval_426&gt;, the first at 0x4019cc, and the latter at 0x4019c5. The <touch2> function is at address 0x4017ec. Putting everything together, we now want the stack to have the following layout, the code bottom being the top of the stack:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00</span><br><span class="line">00 40 17 ec // touch2 address</span><br><span class="line">00 00 00 00</span><br><span class="line">00 40 19 c5 // mov from %rax to %rdi</span><br><span class="line">00 00 00 00</span><br><span class="line">59 b9 97 fa // my cookie</span><br><span class="line">00 00 00 00</span><br><span class="line">00 40 19 cc // pop to %rax</span><br><span class="line">...... 40 bytes random (the original &lt;getbuf&gt; buffer)</span><br></pre></td></tr></table></figure><p>in order to achieve that layout, we want out input to be </p><p><img src="/images/Screenshot-2023-07-16-at-19.41.01-1024x653.png"></p><p><img src="/images/Screenshot-2023-07-16-at-19.41.27-1024x653.png"></p><p>Test it out, and it is indeed the answer. </p><p><strong>Phase5</strong> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;It’s been a while since I wrote posts about CMU’s renowned system course 15-213. Last month, I was primarily devoted to my research on Sm</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Bomb Lab CMU 15-213</title>
    <link href="http://example.com/2023/05/18/bomb-lab-cmu-15-213/"/>
    <id>http://example.com/2023/05/18/bomb-lab-cmu-15-213/</id>
    <published>2023-05-18T08:34:12.000Z</published>
    <updated>2023-12-15T13:03:00.588Z</updated>
    
    <content type="html"><![CDATA[<p>May 18th, 2023. </p><p>I have just finished all my final yesterday. Farewell my sophomore year! After playing the new <em>Zelda: Tears of the Kingdom</em> for the whole evening, which was released just a few days ago (and without any doubt, the best game ever made in human history), I decided to do something a little bit more meaningful and fulfilling. </p><p>I started on the lab assignments of 15-213 when I was still a very naive and stupid freshman (I’ve got to admit that I am kind of stupid in the freshman year…). Back then I don’t know anything about computer systems. It is a terrible terrible mistake to start Intro to Computer Sys when you don’t have a clue what C and POSIX and OS is. The labs will just gradually suck out the false confidence that you got from the undemanding NYU curriculum and the all too high level Python. Apparently, this course is by no means, as its name suggests, an intro one. We’ve got to learn to respect CMU. </p><p>After being through some pretty traumatic experience at Operating Systems and Distributed Systems classes, I decided that I am tortured enough to begin again on the lab assignment of CS:APP. Being a seasoned and perhaps too experienced C programmer, I think I can easily handle an introductory undergraduate course on Systems. (Or can I? Let’s find out!)</p><p>I will skip Data Lab (the first lab) at least for now, because it’s not a particularly interesting one. I will come back to it when I have the time to do so. Bomb lab should be the fun part. Let’s begin with that. </p><p><strong>If you are a student enrolled in CS15-213 at CMU, DON’T MOVE ON!!! Keep in mind that this would constitute a violation of academic integrity. This material is intended to give self-study students some intuition and help when they are stuck and alone with no one to seek help from.</strong> </p><hr><p><em><strong>Phase 0: Preparation</strong></em></p><p>You can either download the source code from the <a href="http://csapp.cs.cmu.edu/3e/labs.html">CS:APP website</a>, or from the <a href="/images/bomb.tar">mirror on this site</a>. </p><p><a href="/images/bomb.tar">bomb</a><a href="/images/bomb.tar">Download</a></p><p>I find this GDB document particularly helpful. It’s clear and detailed. </p><p><a href="/images/gdbnotes-x86-64.pdf">gdbnotes-x86-64</a><a href="/images/gdbnotes-x86-64.pdf">Download</a></p><p>Some commands that are not in the document, but I personally use a lot, are:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; layout src</span><br><span class="line">&gt; layout asm</span><br></pre></td></tr></table></figure><p>This way the assembly &#x2F; code are juxtaposed with the output in a way that is more convenient to read. </p><hr><p><em><strong>Phase 1: Starting with the Simple One</strong></em></p><p>After downloading the bomb, first check out the source file to get a rough idea of what this program is doing. However the source file alone is not very informative. </p><p><img src="/images/Screenshot-2023-05-18-at-15.53.56-1024x636.png"></p><p>Basically for every phase, the program will read an input, and if the input is not correct, it will trigger a signal to set off the alarm. Otherwise that phase is defused. </p><p>The real hint hides within the object file. You may way to first find out what is in the symbol table, by using:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; objdump -t bomb</span><br></pre></td></tr></table></figure><p><img src="/images/Screenshot-2023-05-18-at-15.59.18-1024x749.png"></p><p>Some interesting tags include: phase 1…6, sigalrm_handler, phase_defused… Oh look, there is even something called a secret phase. Is that a bonus?</p><p>Still not very informative, but at least we know where we can set out breakpoints. </p><p><img src="/images/Screenshot-2023-05-18-at-16.03.41-1024x749.png"></p><p>Breaking at phase_1, and run the program, you are required to input a string, as was indicated when we examine the source code. Since I am proud of my own culture and heritage, I will just put here China. (remember that this is a 5 byte string, it is an important hint later). </p><p>Moving on, let’s examine what is in the assembly of phase 1. </p><p><img src="/images/Screenshot-2023-05-18-at-16.10.36-1024x749.png"></p><p>seems like it moves 0x402400 to %esi. An easy guess would be that 0x402400 is a memory address, since we are talking about string here. We cannot put a string in a register, only the address of it. It is worth noting that %esi is the second argument register. So it is clear that we are passing information into a function. Phase_1+9 tells us that this function is called strings not equal. </p><p>But what about %rdi? After all %rdi is the first argument register, and if we use %rsi, that means that %rdi is also used. That is a valid question, and it seems to me that %rdi stores what we input initially, in the initialize_bomb() function call. It will be verified later.</p><p><img src="/images/Screenshot-2023-05-18-at-16.18.06-1024x749.png"></p><p>Remember that before, in phase 1, a function called strings_not_equal is called. Now let’s step into it, and examine what it does. </p><p><img src="/images/Screenshot-2023-05-18-at-16.21.17-1024x749.png"></p><p>The two arguments are each passed first into a function called string_length. It’s not too hard to guess it’s meaning from the name. Apparently, we will jump to strings_not_squal+99 if the length of the two arguments differ. That line will return 1 to phase_1 function, and phase_1, after seeing 1 in %rax, will set off the bomb. BOOM!</p><p><img src="/images/Screenshot-2023-05-18-at-16.26.20-1024x749.png"></p><p>Checking the register value, we found that %r12d has value 5, which happens to be the length of the word “China”. What a wonderful coincidence!</p><p>%rax has value 52, so ah, it seems like the answer string has length 52. We are getting very close to the answer. </p><p>Remember how we stored the address of the correct answer in %rsi, and thar address is 0x402400. All that is left to do is to examine what is store at that address, and exactly 52 words from that, nothing more, nothing less.</p><p>Use the command in GDB to get what you want:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; x/52s 0x402400</span><br></pre></td></tr></table></figure><p><img src="/images/Screenshot-2023-05-18-at-16.32.19-1024x728.png"></p><p>The answer is in the picture. Honestly, I didn’t expect it to be this political LOL.</p><hr><p><em><strong>Phase 2: Let’s Talk About LOOPS!</strong></em></p><p>Phase two is an easy one, took me less than 15 minutes to solve. It is pretty intuitive, given that I got stuck and trained in phase 1. </p><p><img src="/images/Screenshot-2023-05-18-at-20.12.58-1024x591.png">As always, let’s first set a breakpoint at phase_2, and then check what is in the assembly. What I find most intuitive to do is to unfold the loop functions in a series of commands, so that we don’t have to think too much about loop, and that is exactly what I will do. </p><p>First, the compiler saves some callee saved registers that may be altered, then it decrements the stack pointer by 0x28 (pay attention, we are talking about hex here, you will be seriously wrong if you think about decimal, like I once did). </p><p>Then the function calls a function named &lt;read_six_numbers&gt;. I don’t even bother to step into that particular function, because its purpose is already all too clear from the name itself. It just read 6 numbers, and it seems that this time, we need to input 6 numbers as the answer. </p><p>Six numbers, that is really a lot. Apparently, the compiler will not use the register to save these 6 numbers, what it will do is to store the 6 numbers on the stack, starting from the stack pointer %rsp obviously. </p><p><img src="/images/Screenshot-2023-05-18-at-20.23.45-1024x591.png">The phase_2 assembly from the previous picture is not complete, with this pic, it is complete now. </p><p>We definitely want to jump at line phase_2+18, otherwise the bomb will explode! To jump, we must make sure that the number in *(%rsp) is 0x1, so the first number we input should be 1. </p><p>Now that we have jumped to line phase_2+52, %rbx &#x3D; 4 + %rsp (we are not yet dereferencing here), %rbp &#x3D; 18+%rsp. And then we jump back to line phase_2 + 27. </p><p>Starting from line phase_2+27, %eax &#x3D; * (%rbx-4) &#x3D; * (%rsp) (we are dereferencing here), %eax &#x3D; 2 * %eax, since we want to jump at line phase_2 + 34 to avoid triggering the bomb at line 36, %eax should be equal to *(%rbx), in other words, *(4+rsp) &#x3D; 2 * (*%rsp). So what should be the second element in the 6 int array we input then? Apparently 2!!!</p><p>Jumping to line 41, %rbx &#x3D; %rbx + 4 &#x3D; %rsp + 8. If %rbx !&#x3D; %rsp + 24, then we loop back to line 27, where we must make sure that the latter element is twice as big as the previous element. However, if we are lucky enough to have %rbx &#x3D; %rsp + 24, which will eventually happen after 6 iterations, we will just go to line 64, restore the stack, and then return. With that said, it is pretty apparent that the sequence of number should be 1 2 4 8 16 32, since we are inputting 6 numbers as specified. </p><p><img src="/images/Screenshot-2023-05-18-at-20.42.57-1024x591.png"></p><p>We tried that out, it is indeed the solution!!!!!!! So exciting!!!!!!!! </p><hr><p><em><strong>Phase 3: Jumping Around!</strong></em></p><p>Today is May, 19th, 2023. After a long hard day working on the impossible research project, I finally had some time to myself. (Maybe I will write a post about that project a little bit later, I do believe that it is a very meaningful and truly inaugurating project, but it looks VERY formidable). </p><p>Phase 3 of the bomb lab is a lot more difficult than the previous two, I have got to admit. I have to spend around an hour to solve this problem. </p><p>As always, first we will set a break point at phase_3, and run the program as usual. You can first input anything, as long as we quit GDB before the bomb is set off, we are fine. </p><p>if you do that, here should be what you see:</p><p><img src="/images/Screenshot-2023-05-19-at-20.00.08-1024x591.png">Stopping right before phase_3 begins. </p><p>I am utterly curious what is store at address 0x4025cf, since it is passed as an argument to the sscanf function at line 24. So I examine what was in that address. </p><p><img src="/images/Screenshot-2023-05-19-at-20.03.58-1024x591.png">As it shows, it stores a string, whose content is two place holders for decimal values. (Why do I print it as String? Well, the sscanf function kind of gives you a hint. sscanf function should take as input a string (out input, and a string representing the place holders like %d %d). </p><p>This belief is collaborated by the fact the at line phase_3 + 19, the program requires that the return value of sscanf should be bigger than 0, otherwise, the bomb will explode. The return value of sscanf should be the number of integers parsed successfully. Though trial and failure, you will indeed find that, no matter how many numbers you try to input, the result will still be 2 at most, since we only have 2 place holders for integers. </p><p>With that knowledge in mind, we should adjust our input accordingly, so that we can at least survive past line 34. I will just input 6 8. They are all lucky numbers in China!</p><p>Since we are moving on to deal with the content in the stack, I think that it was high time that we examine what is now in the stack. </p><p><img src="/images/Screenshot-2023-05-19-at-20.15.01-1024x591.png"></p><p>We find that 6 and 8 that we input before is now in the stack, thanks to the sscanf function. What are the first 2 bytes, I really don’t care. I just need to know where my inputs are stored.</p><p>So apparently, we are jumping at line phase_3 + 50, to a mysterious place based on the stuff in *($rsp+8), which happens to be our first input number. </p><p><img src="/images/Screenshot-2023-05-19-at-20.18.47-1024x591.png"></p><p>There are several lines doing similar things, storing a number in %rax, and jump to line 123. At line 123, we want to make sure that *(12+%rsp)&#x3D;&#x3D;%eax, whatever was put into %rax at previous steps. Note that 12+%rsp is the place where we store our second input number!!!</p><p>Now things are clearing up!!!!!!!!!!!! We jump to a certain line based on out first input, the program will then put a certain number into %rax, we just need to make sure that our second input is the same as the number put into that register!!!!!!!!!! GOOD!!!!!!!!!!!!!!!</p><p>For simplicity, I will make the first number 0. There is no reason to calculate which line we jumps to by hand, use GDB’s nexti to find out where we jump to, and then adjust the second input number accordingly.</p><p><img src="/images/Screenshot-2023-05-19-at-20.24.03-1024x591.png"></p><p>So we find that with 0 we jump to line 57, which puts 0xcf into %rax. 0xcf is 207 in decimal. Try 0 207 as a tentative answer, and phase 3 will be defused successfully!</p><p><img src="/images/Screenshot-2023-05-19-at-20.26.34-1024x591.png">As I alluded to, you can also try 1 as the first input, step with GDB, and you will find that the second input should be decimal 311. 1 311 is also a valid answer! </p><p>You can try more, but I will stop here. Hoped that you enjoyed it so far!!!</p><hr><p><em><strong>Phase 4: Function Calls</strong></em></p><p>Today is May 21st, 2023. I am trying to finish one phase per day of this lab. This is a little ambitious, because I play too hard during the summer holiday. </p><p>Luckily, phase 4 of the lab is not a difficult one, as I get more experience with assembly along the way. It took me around half an hour to solve this problem. </p><p>As always, let’s set a breakpoint at phase_4 first, and then step through the assembly. Here is what we get when we inspect phase_4 of the code. </p><p><img src="/images/Screenshot-2023-05-21-at-21.15.11-1024x653.png"></p><p>Okay, apparently, we are using sscanf to turn our string input into numbers, or something else. The question that remains is how many numbers we should input? We could find this out by inspecting the second argument of sscanf, which is what is stored in %esi: 0x4025cf. This is quite similar to what we did in phase_3, and because I still remembered that from two days ago, this step is quite intuitive.</p><p><img src="/images/Screenshot-2023-05-21-at-21.22.06-1024x653.png">It is expecting a string of the format “%d %d”. </p><p>So by inspecting the format stored at 0x4025cf, we should input two numbers. Now the central question becomes, which two numbers should we input? To answer that, we need to inspect the assembly further.</p><p>First we allocate on the stack 18 bytes. %rcx &#x3D; 12 + %rsp. %rdx &#x3D; 8 + %rsp. Again, these two registers are arguments passed into the sscanf function. This alludes to the fact that the two numbers that we input to the program are each stored in 8+%rsp and 12+%rsp. This fact can be checked by inputing two random numbers and then inspect the stack, which I will omit here since it has been demonstrated previously. I really cannot decipher what ws in the first 8 bytes starting at %rsp, nor do I really care about it. </p><p>Then, it is apparent that if we want to avoid triggering the bomb, then we should really make sure that we jump at line 39. In order to jump, we have to make sure that the first input is smaller than or equal to the number 0xe, which is 14 in decimal. </p><p><img src="/images/Screenshot-2023-05-21-at-21.45.18-1024x653.png"></p><p>Line 69 also requires that the second input, which is stored at 0xc(%rsp), should be equal to 0. </p><p>It is calling a procedure called <func4>, and the arguments are: %rdx&#x3D;14, %rsi&#x3D;0, %rdi&#x3D;first input. Let’s move on to inspect what is going on in <func4>, shall we?</p><p><img src="/images/Screenshot-2023-05-21-at-21.48.26-1024x653.png">Stepping into <func4></p><p>Now we are stepping into func4, %rax &#x3D; %rdx &#x3D; 14, %eax &#x3D; %eax - %esi &#x3D; 14 - 0 &#x3D; 14, %ecx &#x3D; 14. Shift %ecx right by 31 bits, and store the result back in %ecx, so %ecx should be the sign bit of 14, which is 0. %eax &#x3D; %eax + %ecx &#x3D; %eax + 0 &#x3D; %eax &#x3D; 14. %eax shift arithmetic right by 1 bit, which makes %eax 7 (divide by 2). At line 17, %ecx &#x3D; %rax + 1 * %rsi &#x3D; 7 + 1 * 0 &#x3D; 7. We don’t really want to call <func4> recursively at line 27, so %edi had better be less than or equal to %ecx, with %edi being the first input and %ecx being 7. </p><p>Assume that we jumped successfully to line 36, which moves 0 to %eax (this is what we want, since we want at line phase_4 + 65, that the return value of func4 being 0, to avoid setting the bomb off!!!). Then we really want %edi &gt;&#x3D; %ecx, to avoid the recursive calls to func4. Remember that previously, we want %edi &lt;&#x3D; %ecx, so these two should really be equal, which gives us the right first input: 7. </p><p><img src="/images/Screenshot-2023-05-21-at-22.02.22-1024x653.png">Just to give you the full picture what <func4> is doing…</p><p>Recall that I said that the second input should be 0, and we need two numbers exactly. The answer is here: </p><p>7 0</p><p>There may be more than 1 answer, but I will stop here. </p><p><img src="/images/Screenshot-2023-05-21-at-22.06.16-1024x653.png">And we are successful, it is indeed the answer!!!</p><hr><p> <em><strong>Phase 5: Cracking ASCII Code</strong></em></p><p>Hey guys, it’s midnight on May 21, 2023, 23:53. I have just finished phase 5 of the bomb lab (two phases in one night, because it is really super FUN!!!!!!). I am writing overnight in case I forget how to solve this problem when I wake up in the morning…. And also partly because I am so excited right now LOL. </p><p>This phase is worth extra credits, because it is supposed to be more difficult. However, I found the difficulty very acceptable, and it took me around 30 minutes to solve this problem. So don’t be terrified by the apparent complexity of this problem. If you have been following along, you have what it takes to solve this problem very easily. </p><p>As usual, let’s set a breakpoint at phase_5, and then examine the assembly via GDB. </p><p><img src="/images/Screenshot-2023-05-21-at-23.59.16-1024x653.png"></p><p>So it allocate for the stack a space of 32 bytes, but the last 8 byte of the stack is protected by the canary to protect the process from stack overflow attack (this is a GCC default). So really the actual amount of space we can use on the stack is 24 bytes. </p><p>Then we use xor to force %eax to become 0, and then call the procedure &lt;string_length&gt;. We want to make sure that the return value in %rax is 6, otherwise the bomb will be triggered. So apparently the length of our input should be of a string of length 6, and we will jump to line 112. </p><p><img src="/images/Screenshot-2023-05-22-at-06.40.27-1024x653.png"></p><p>Line phase_5 + 112 just clears the content in %eax, and then jump back to line 41, which, as we will see, is a loop that serves as the main logic. </p><p><img src="/images/Screenshot-2023-05-22-at-06.46.12-1024x653.png">Moving back to line 41… It looks that we are in a do-while loop. </p><p>Let’s examine this part of the ASM closely. It first stores the character at address (%rbx + 1 * %rax) &#x3D; %rbx &#x3D; input string starting address, to the register %ecx. It moves the lowest byte of %ecx to address (%rsp). It then moves the content at address (%rsp) to register %rdx, and AND with 0xf the last 4 bits. So now what is left in %rdx is the last four bits of the first character of our input. </p><p>Now we are at line phase_5 + 55, which is moving the byte at address 0x4024b0 + %rdx to register %edx, and moves the lowest byte to address %rsp + 1 * %rax + 16, and then reenter the loop until all 6 characters have been iterated. In other words, the i th byte that we load to the upper part of the stack frame (starting at the 16th byte and should not exceed the 24th byte because of the stack protector of GCC) depends on the last 4 bits of the ith character of our input stirng. </p><p>Then we should make sure that the new string at the upper part of the stack frame should be equal to the string stored at address 0x40245e, both address are passed as arguments into a function called &lt;strings_not_equal&gt;. If they are the same, then the bomb will be defused.</p><p>So let’s first find out which string we are trying to match here. </p><p><img src="/images/Screenshot-2023-05-22-at-07.15.56-1024x653.png">So apparently we are trying to construct a string called “flyers”. And we are selecting from a reserve of characters, starting at address 0x4024b0 from line phase_5 + 55. </p><p><img src="/images/Screenshot-2023-05-22-at-07.18.34-1024x653.png"></p><p>So we have”maduiersnfotvbyl” to choose from, which contains all characters in the string “flyers”. Also note that we only have 16 characters here, which is the maximum number of choices that can be represented with 4 bits, since we are only using the last 4 bits of each character of our input as offset into this character reserve. This cannot be a coincidence, we are in the right place bro.</p><p>So we want our offset at %edx to be 9, 15, 14, 5, 6, 7 to get “flyers”, which translate into binary “1001 1111 1110 0101 0110 0111”, and all we need to do is to find 6 characters whose lower 4 bits are exactly that. </p><p><img src="/images/Screenshot-2023-05-22-at-07.24.32-1024x626.png"></p><p>Checking the ASCII table, this string could be, but not necessarily, “<strong>9 ? &gt; 5 6 7</strong>“ since the lowest 4 bits matches. </p><p>We try this, and this is indeed the answer!</p><p><img src="/images/Screenshot-2023-05-22-at-07.26.18-1024x653.png">Not too hard, right? Told you</p><hr><p><em><strong>Phase 6: Linked List and Sorting</strong></em></p><p>The last phase of the bomb is significantly more complex than previous phases. It makes heavy use of pointers and array, which makes this procedure call a lot more complex. I will try my best to explain what is going on. </p><p>Let’s give out the answer first, because, why not? We input 4 3 2 1 6 5, and then see what will happen. </p><p><img src="/images/Screenshot-2023-05-23-at-11.02.50-1024x591.png"></p><p>The first part of the code, from the first line to &lt;phase_6+93&gt;, is doing these: first read in 6 numbers from the standard input, put them at the beginning of the stack frame (as was done usually, this can be verified by printing the stack), check that all numbers are equal to or less then 6 (line phase_6+52, 56), and then check, using a for loop, that every number after is different from itself. This can be roughly reverse engineered to the following code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">read_six_numbers from stdin;</span><br><span class="line"></span><br><span class="line">store them on the stack, starting from %rsp; (use arr to represent the six number array)</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 6; i++)&#123;</span><br><span class="line">    if (arr[i] &gt; 6) &#123;</span><br><span class="line">        ABORT;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j = i; j &lt; 6; j++) &#123;</span><br><span class="line">        if (arr[j] == arr[i]) &#123; ABORT;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Screenshot-2023-05-23-at-11.11.59-1024x591.png"></p><p>The second part of the assembly, from &lt;phase_6+95&gt; to &lt;phase_6+121&gt;, is subtracting each number from 7, and store the result of the subtraction at the original stack position. This can be translated into the following pseudo code.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; 6; i++)&#123;</span><br><span class="line">    arr[i] = 7 - arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Screenshot-2023-05-23-at-11.21.04-1024x591.png"></p><p>The third part of the code puts address of each node to the stack frame, starting at position rsp+32. The most important address to understand is 0x6032d0. Print it and you will discover that the memory that this address points to store a linked list, though all its nodes are in a contiguous memory. </p><p><img src="/images/Screenshot-2023-05-23-at-12.08.11-1024x331.png">Printing the memory at 0x6032d0, something that I did not notice the first time is that the author gives you hint that this is a linked list data structure. Notice the yellow part of the disassembly actually says “node1”. The first field of each node seems to store the element, the second field is the index, the third field is the pointer to the next node, and the fourth field is what we call <em><strong>alignment,</strong></em> which speed up the memory fetch of a struct. </p><p><img src="/images/Screenshot-2023-05-23-at-12.10.35-1024x212.png">In hex, makes the address that the second word of each node points to clearer. The linked list is actually contiguous in memory here. </p><p>It takes some time to get a grasp of what the assembly is doing here. The rough idea is that it is storing the address of each node in the stack, and the sequence is in accordance of the 6 numbers we input (remember that we take 7 - i for each i we input, so the actual sequence is reversed. In other words, if the first number we input is 2, then the 3rd node will be stored in the 5th place of the array on the stack). If we take a breakpoint after all this madness has ended &lt;at phase_6 + 183&gt;, and then print out the stack memory, we will find that this is indeed the case. </p><p><img src="/images/Screenshot-2023-05-23-at-12.17.32-1024x202.png">After all madness ended, this is the memory layout. Starting at the third line, every word stores the starting address of the node. Nodes are put in a sequence that is relevant with our input to the program. </p><p><img src="/images/Screenshot-2023-05-23-at-12.44.02-1024x217.png">After executing through &lt;phase_6+183&gt; to &lt;phase_6+220&gt;</p><p>From line phase_6+183 to phase_6+220, the code does not do much. As we can tell from the above picture, which is the result of the execution of this part of the code, it just make the singly linked list a ring, pointing from the tail to the head. </p><p><img src="/images/Screenshot-2023-05-23-at-12.56.56-1024x591.png"></p><p>The last part of the code checks that each node stored in the array on the stack has a bigger element than the next node (here by next I don’t mean the next node pointer, but rather the sequence we input). If it is bigger, than we can defuse the bomb successfully. Otherwise, the bomb goes off. </p><p>It is okay if you cannot decipher every line of the assembly, <strong>just focus on the result of each part of the code</strong>, and try to guess (or in a fancier term, reverse engineer) what is going on in each part. In all previous phases, I can understand each line of the disassembly with ease, but the last phase is different. I learned to focus on the result, instead of trying to decipher every line of the disassembly, because there are just too many lines. </p><p>So apparently, we kind of get the rough idea, after dividing the code into blocks, and then interpret the result of the execution of each code block, that we are sorting a linked list here, and the number we input reflects the order of the element of nodes. In the last part, we want to make sure that on the stack, nodes are put in decreasing order: 3 4 5 6 1 2. But since we take each number off 7 previously, the sequence we give to the program should be 4 3 2 1 6 5. </p><p><img src="/images/Screenshot-2023-05-23-at-13.05.46-1024x591.png">Put 4 3 2 1 6 5 to sol.txt, and then run the program. </p><p>Test it, and indeed, this is the result. We have defused the bomb successfully!!!</p><p><em><strong>This concludes this lab assignment.</strong></em></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;May 18th, 2023. &lt;/p&gt;
&lt;p&gt;I have just finished all my final yesterday. Farewell my sophomore year! After playing the new &lt;em&gt;Zelda: Tears o</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Paper Reading - CS Model - Some constraints and tradeoffs in the design of network communications</title>
    <link href="http://example.com/2023/02/17/paper-reading---cs-model---some-constraints-and-tradeoffs-in-the-design-of-network-communications/"/>
    <id>http://example.com/2023/02/17/paper-reading---cs-model---some-constraints-and-tradeoffs-in-the-design-of-network-communications/</id>
    <published>2023-02-17T12:30:20.000Z</published>
    <updated>2023-12-15T12:55:09.296Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://yaoyuncheng.site/wp-content/uploads/2023/02/client-server-issues-Akkoyunlu-et-al-75.pdf">client-server-issues-Akkoyunlu-et-al-75</a><a href="http://yaoyuncheng.site/wp-content/uploads/2023/02/client-server-issues-Akkoyunlu-et-al-75.pdf">Download</a></p><p>Name: Yuncheng Yao (Peter)</p><p>Reference: E. A. Akkoyunlu, K. Ekanadham, and R. V. Huber. 1975. Some constraints and tradeoffs in the design of network communications. In Proceedings of the fifth ACM symposium on Operating systems principles (SOSP ‘75). Association for Computing Machinery, New York, NY, USA, 67–74. DOI:<a href="https://doi.org/10.1145/800213.806523">https://doi.org/10.1145/800213.806523</a></p><hr><p>The challenge that the authors address is how to incorporate many desirable but sometimes conflicting features into a client server model, by making necessary tradeoffs to solve the incompatibility. </p><p>Some reasonable assumptions about the system are made. The clients and servers communicate via messages and ports; the most complex failure model is the timing failure, and failures may be silent; the system is asynchronous in terms of communication and computation; there is no mysterious system buffering as in MPI; failure intervals are long compared to the transaction time. </p><p>The author also ruled out some unreasonable assumptions. It is not realistic to assume that 1)the network is reliable; 2)the topology is connected all the time; and 3) failures can be detected immediately.</p><p>The features that the authors want to include in theirs systems are:</p><ol start="2"><li><p>Status. Because status information cannot be provided elsewhere if it is not provided in the IPCM;</p></li><li><p>Time-out. Because we don’t want to block the whole process forever just because of a single undelivered message;</p></li><li><p>Insertion property. This provides maximum abstraction to the users by supplying them with limited communication primitives;</p></li><li><p>Well known ports. It exposes frequently used resources like HTTP, compiling, FTP… ;</p></li><li><p>Partial transfer to deal with different buffer sizes;</p></li></ol><p>The authors identify some inevitable incompatibility among those desirable features and proposed possible solutions to have them all by making acceptable compromises.</p><ol start="2"><li><p>The conflict between the incomplete connectedness of the topology (eg. network partition) and providing complete status. Accurate status messages may be blocked by a partition.</p></li><li><p>The conflict between time-outs and complete status. Even with the strong assumption that the network is reliable, because of the asynchronous nature of our communication model, a status message may not arrive before the time-out, and we cannot be sure whether the message got delivered and accepted (but is still being processed by the server), got delivered and rejected, or that the status information is sent but not yet received.</p></li><li><p>The conflict between time-outs and insertion property. Similar to Conflict 2, it is impossible to be sure about the exact outcome of the transaction with time-outs, a situation that cannot happen had these two processes been directly connected on a centralized system, and this uncertainty violates the insertion property.</p></li></ol><p>The solution to the first 3 conflicts is to provide the same ambiguous status information in many situations where we are not certain about the exact correct status . Whether the message is never delivered successfully, or the delivery to the server is complete but status is not sent in time, or that the status is sent but not received by the client in time, it is the same ambiguous status provided to the client. The tradeoff that we are making is that we are unable to provide complete status, but we will be able to provide some status.</p><ol start="5"><li>The conflict between the strong insertion property and the varying buffer sizes of different processes. Enforcing a universal buffer size is restricting, and violates insertion property by exposing communication details.</li></ol><p>Solution: Allow partial transfers.</p><ol start="6"><li>The conflict among partial transfer, time-outs and insertion property. The RECEIVE request may time out before a complete message is transferred, and by telling the server process about the data existing in the buffer, we expose ugly communication details and violate insertion property; if we don’t tell the server process about the incomplete message, the message gets lost.</li></ol><p>Solution: Adopt a weaker insertion property and allow buffer sizes to be exposed when necessary.</p><ol start="7"><li>The conflict between well-known ports, partial transfer and time-outs. Time-outs are necessary here, otherwise the well-known port may be blocked by a super slow message. New messages arriving after the original SEND request has timed out raises data consistency issues.</li></ol><p>Solution: Ban partial transfer with well-known ports. Longer messages sent to the well-known process must use separate connections which are set up after the initial short message sent to the well-known port, which potentially use a layer of buffer processes, or communicate via another port.</p><ol start="8"><li>The conflict between many ports processes and partial transfers. With or without a separate buffer for each port, once a complete message arrives while there is an incomplete one, the server process has to deal with the incomplete message by buffering it internally, which violates the insertion property.</li></ol><p>Solution: add a layer of buffer processes, which sends only complete messages to the server.</p><p>The paper also proves that it is impossible for the client and server to know that they are in mutual agreement about the status of the original message from client to the server. The implication is that it is not necessary to send status information more than once, because no matter how many times you send the status and ACK of the status, you can never be sure that you are in mutual agreement with each other.</p><p><strong>Strengths of the paper:</strong></p><ol start="2"><li><p>The insertion property is strict but helpful. By exposing limited and general primitives to the application layer, we can easily insert service layers on the communication path without interfering with the users. We have seen a beautiful layer of buffer processes, which spare the service process the trouble to provide internal buffering for partial transfers. One can further imagine that, when the load is big, we may add a layer of load-balancing dispatcher processes, without interfering with the client or the server. This powerful insulation and abstraction allows for maximum forward compatibility.</p></li><li><p>The use of concurrent programming to increase the throughput. The design of buffer processes allows a service process to use the RECEIVE primitive concurrently. This is a huge improvement in terms of throughput, now that a service process doesn’t have to receive messages one by one. This is concurrency on the communication layer, and with the potential implementation of concurrency within the service process itself, the overall efficiency of this CS model is good.</p></li></ol><p><strong>Weaknesses of the paper:</strong></p><ol start="2"><li><p>If the clients keep sending requests when the server is already busy, the service process may well run out of buffer space, and data may be lost. Some traffic control may be desirable to ensure that there is enough capacity on the server side.</p></li><li><p>The overhead induced by dynamic creation of buffer processes is costly. It may be an optimization to use a dynamic process pool, or even a thread pool for buffering partial transfers, which reduces the overhead of process creation, and provides a cap for server capacity.</p></li><li><p>The time-out feature is necessary in the CS model, for reasons aforementioned, but the exact time-out window could potentially be optimized by adding a failure detection layer. By dynamically calculating the estimated arrival time, we may be able to improve the completeness and accuracy of the time-out feature.</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://yaoyuncheng.site/wp-content/uploads/2023/02/client-server-issues-Akkoyunlu-et-al-75.pdf&quot;&gt;client-server-issues-Akkoyunlu-e</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Higher-order Functions</title>
    <link href="http://example.com/2023/02/14/higher-order-functions/"/>
    <id>http://example.com/2023/02/14/higher-order-functions/</id>
    <published>2023-02-14T07:07:51.000Z</published>
    <updated>2023-12-15T12:55:09.294Z</updated>
    
    <content type="html"><![CDATA[<p>A higher order function is technically any function that takes another function as an argument.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;A higher order function is technically any function that takes another function as an argument.&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
