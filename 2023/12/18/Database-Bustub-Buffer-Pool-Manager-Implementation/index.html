<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>[Database] Bustub Buffer Pool Manager Implementation - Peter Yuncheng Yao</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Peter&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Peter&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Implement a buffer pool manager for a DBMS, from scratch, in C++.  Per CMU policy, Bustub solution should not be made public. Hence, only code snippets and logic are shown here. If you need to see the"><meta property="og:type" content="blog"><meta property="og:title" content="[Database] Bustub Buffer Pool Manager Implementation"><meta property="og:url" content="http://peteryaonyu.github.io/2023/12/18/Database-Bustub-Buffer-Pool-Manager-Implementation/"><meta property="og:site_name" content="Peter Yuncheng Yao"><meta property="og:description" content="Implement a buffer pool manager for a DBMS, from scratch, in C++.  Per CMU policy, Bustub solution should not be made public. Hence, only code snippets and logic are shown here. If you need to see the"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://peteryaonyu.github.io/images/gradescope_bmp.png"><meta property="article:published_time" content="2023-12-19T00:18:38.000Z"><meta property="article:modified_time" content="2024-01-09T04:15:14.016Z"><meta property="article:author" content="Yuncheng Yao"><meta property="article:tag" content="Peter Yuncheng Yao, Peter Yao, Peter Y. Yao, Peter Yao NYU, Peter Yao NYU Shanghai, Peter Yao NYUSH, Peter Yao NYU S"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://peteryaonyu.github.io/images/gradescope_bmp.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://peteryaonyu.github.io/2023/12/18/Database-Bustub-Buffer-Pool-Manager-Implementation/"},"headline":"[Database] Bustub Buffer Pool Manager Implementation","image":["http://peteryaonyu.github.io/images/gradescope_bmp.png"],"datePublished":"2023-12-19T00:18:38.000Z","dateModified":"2024-01-09T04:15:14.016Z","author":{"@type":"Person","name":"Yuncheng Yao"},"publisher":{"@type":"Organization","name":"Peter Yuncheng Yao","logo":{"@type":"ImageObject","url":{"text":"Yao Yuncheng(Peter)"}}},"description":"Implement a buffer pool manager for a DBMS, from scratch, in C++.  Per CMU policy, Bustub solution should not be made public. Hence, only code snippets and logic are shown here. If you need to see the"}</script><link rel="canonical" href="http://peteryaonyu.github.io/2023/12/18/Database-Bustub-Buffer-Pool-Manager-Implementation/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Peter Yuncheng Yao" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Yao Yuncheng(Peter)</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/CV">CV</a><a class="navbar-item" href="/publication">Publication</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PeterYaoNYU"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-12-19T00:18:38.000Z" title="12/18/2023, 7:18:38 PM">2023-12-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2024-01-09T04:15:14.016Z" title="1/8/2024, 11:15:14 PM">2024-01-08</time></span><span class="level-item">18 minutes read (About 2648 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">[Database] Bustub Buffer Pool Manager Implementation</h1><div class="content"><p>Implement a buffer pool manager for a DBMS, from scratch, in C++. </p>
<p><em><strong>Per CMU policy, Bustub solution should not be made public. Hence, only code snippets and logic are shown here. If you need to see the code, email me: <a href="mailto:&#121;&#x79;&#52;&#x31;&#x30;&#x38;&#64;&#110;&#x79;&#x75;&#46;&#x65;&#100;&#117;">&#121;&#x79;&#52;&#x31;&#x30;&#x38;&#64;&#110;&#x79;&#x75;&#46;&#x65;&#100;&#117;</a>.</strong></em></p>
<span id="more"></span>

<p>I am on my train to Qingdao right now, to see a beautiful girl. I am not so sure about how I feel, excited, but at the same time nervous. It is even freezing in Shanghai recently, let alone Qingdao. It is my first time, travelling so far, just to see someone.</p>
<p>I want to be productive on a train, but it is not easy. Writing something about buffer pool manager will probably calm me down. </p>
<p>We will follow the guides and instruction of <em><strong>Andy Pavlo</strong></em>, and his <em><strong>CMU 15-445</strong></em> course, to implement a buffer pool manager for a database management system, in C++. </p>
<p>First, let me prove myself with a Gradescoppe screenshot. </p>
<p><img src="/images/gradescope_bmp.png"></p>
<p>You can indeed be convinced that I know what I will be talking about. </p>
<h3 id="LRU-K-Replacement-Policy"><a href="#LRU-K-Replacement-Policy" class="headerlink" title="LRU-K Replacement Policy"></a>LRU-K Replacement Policy</h3><p>Implementing an eviction policy is always the first step in any buffer pool manager implementation. The reason being that we always need to figure out a way to decide which page (frame) to evict when the buffer pool is full.</p>
<p>Per the instruction of CMU, here we will be implementing an LRU-K policy. First letâ€™s take a look at what is expected in an LRU replacer. </p>
<blockquote>
<p>The LRU-K algorithm evicts a frame whose backward k-distance is maximum of all frames in the replacer. Backward k-distance is computed as the difference in time between current timestamp and the timestamp of kth previous access. A frame with fewer than k historical accesses is given +inf as its backward k-distance. <strong>When multiple frames have +inf backward k-distance, the replacer evicts the frame with the earliest overall timestamp (i.e., the frame whose least-recent recorded access is the overall least recent access, overall, out of all frames).</strong></p>
</blockquote>
<blockquote>
<p>The maximum size for the <code>LRUKReplacer</code> is the same as the size of the buffer pool since it contains placeholders for all of the frames in the <code>BufferPoolManager</code>. However, at any given moment, not all the frames in the replacer are considered to be evictable. The size of <code>LRUKReplacer</code> is represented by the number of <em>evictable</em> frames. The <code>LRUKReplacer</code> is initialized to have no frames in it. Then, only when a frame is marked as evictable, replacerâ€™s size will increase.</p>
</blockquote>
<p>With the basic idea in mind, letâ€™s discuss how to implement in detail. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRUKReplacer::<span class="built_in">LRUKReplacer</span>(<span class="type">size_t</span> num_frames, <span class="type">size_t</span> k) : <span class="built_in">replacer_size_</span>(num_frames), <span class="built_in">k_</span>(k) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>First, implement the constructor. num_frames is the number of total frames available, and the k_ here should be the number of evictable frames. </p>
<p>The main logic of LRU-K is in the Evict function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">LRUKReplacer::Evict</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node_store_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// there is no evictable frame</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> max_distance = <span class="number">0</span>;</span><br><span class="line">  <span class="type">frame_id_t</span> candidate = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">bool</span> found_infinite = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pair : node_store_) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;node = pair.second;</span><br><span class="line">    <span class="keyword">if</span> (!node.is_evictable_ || node.history_.<span class="built_in">size</span>() &lt; k_) &#123;</span><br><span class="line">      <span class="comment">// if it has less than k history elements, its k distance is set to +inf</span></span><br><span class="line">      <span class="keyword">if</span> (node.is_evictable_ &amp;&amp; node.history_.<span class="built_in">size</span>() &lt; k_) &#123;</span><br><span class="line">        <span class="comment">// there hasn&#x27;t been an element whose k distance is +inf</span></span><br><span class="line">        <span class="keyword">if</span> (!found_infinite) &#123;</span><br><span class="line">          max_distance = std::numeric_limits&lt;<span class="type">size_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">          candidate = node.fid_;</span><br><span class="line">          found_infinite = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// based on LRU, if there are multiple frames with +inf k distance</span></span><br><span class="line">          <span class="comment">// evict the one with the smallest timestamp</span></span><br><span class="line">          <span class="keyword">if</span> (node.history_.<span class="built_in">front</span>() &lt; node_store_[candidate].history_.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            candidate = node.fid_;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// continue the execution, skip this node</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> distance = current_timestamp_ - node.history_.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (distance &gt; max_distance) &#123;</span><br><span class="line">      max_distance = distance;</span><br><span class="line">      candidate = node.fid_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (candidate != <span class="number">-1</span>) &#123;</span><br><span class="line">    *frame_id = candidate;</span><br><span class="line">    node_store_.<span class="built_in">erase</span>(candidate);</span><br><span class="line">    curr_size_--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The logic is simple:</p>
<ol>
<li>check all nodes that are marked evictable by the replacer. </li>
<li>If it has less than k elements, then its k distance is set to infinite (the most likely to be replaced). </li>
<li>If we have multiple +inf distance nodes, then fall back to the original LRU policy. Just pick the oldest among these +inf nodes. (This is the purpose that <em>found_infinite</em> is servering)</li>
<li>Otherwise, if all evictable pages have more than k access records, follow the LRU-K policy, and pick the oldest.</li>
</ol>
<p>RecordAccess function is also important. It should be called anytime we touch a frame (read&#x2F;write it from the buffer pool manager). </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::RecordAccess</span><span class="params">(<span class="type">frame_id_t</span> frame_id, [[maybe_unused]] AccessType access_type)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If frame id is invalid (ie. larger than replacer_size_), throw an exception.</span></span><br><span class="line">  <span class="keyword">if</span> (frame_id &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(replacer_size_)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(ExceptionType::OUT_OF_RANGE, <span class="string">&quot;frame id is out of range&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ++current_timestamp_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if the frame_id exists in node_store_.</span></span><br><span class="line">  <span class="keyword">auto</span> it = node_store_.<span class="built_in">find</span>(frame_id);</span><br><span class="line">  <span class="keyword">if</span> (it == node_store_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// If not found, initialize a new LRUKNode and insert it into node_store_.</span></span><br><span class="line">    LRUKNode new_node;</span><br><span class="line">    new_node.fid_ = frame_id;</span><br><span class="line">    new_node.history_.<span class="built_in">push_back</span>(current_timestamp_);</span><br><span class="line">    new_node.k_ = k_;  <span class="comment">// Assuming k_ is a property you want to set during initialization.</span></span><br><span class="line">    node_store_.<span class="built_in">emplace</span>(frame_id, std::<span class="built_in">move</span>(new_node));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If found, update the existing node.</span></span><br><span class="line">    <span class="keyword">auto</span> &amp;node = it-&gt;second;</span><br><span class="line">    <span class="keyword">if</span> (node.history_.<span class="built_in">size</span>() &gt;= k_) &#123;</span><br><span class="line">      node.history_.<span class="built_in">pop_front</span>();  <span class="comment">// Ensure only the last k timestamps are kept.</span></span><br><span class="line">    &#125;</span><br><span class="line">    node.history_.<span class="built_in">push_back</span>(current_timestamp_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>fist check if the page that you are trying to access is actually legal. If not, raise an exception. </li>
<li>If the LRU node is already in the Hash Map, just update the node history (evict the oldest if there is more than K accesses)</li>
<li>if not found, init a new node element in the hash map.</li>
</ol>
<p><em><strong>SetEvictable</strong></em> is simple, you just need to check if the frame_id you are setting is legal and can actually be found in the hash map. Then you set evictablity based on the parameter. Finally, remember to update the current_size_, which represents the number of evictable pages. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUKReplacer::SetEvictable</span><span class="params">(<span class="type">frame_id_t</span> frame_id, <span class="type">bool</span> set_evictable)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If frame id is invalid (ie. larger than replacer_size_), throw an exception.</span></span><br><span class="line">  <span class="keyword">if</span> (frame_id &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(replacer_size_)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(ExceptionType::OUT_OF_RANGE, <span class="string">&quot;frame id is out of range&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = node_store_.<span class="built_in">find</span>(frame_id);</span><br><span class="line">  <span class="keyword">if</span> (it == node_store_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(ExceptionType::OUT_OF_RANGE, <span class="string">&quot;Frame ID does not exist, cannot find the frame.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> &amp;node = it-&gt;second;</span><br><span class="line">  <span class="keyword">if</span> (node.is_evictable_ != set_evictable) &#123;</span><br><span class="line">    node.is_evictable_ = set_evictable;</span><br><span class="line">    curr_size_ += set_evictable ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The last componenet of an LRU is a <em><strong>Remove</strong></em> function, which removes everything from the replacer related with a certain page. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">oid <span class="title">LRUKReplacer::Remove</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If frame id is invalid (ie. larger than replacer_size_), throw an exception.</span></span><br><span class="line">  <span class="keyword">if</span> (frame_id &gt;= <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(replacer_size_)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(ExceptionType::OUT_OF_RANGE, <span class="string">&quot;frame id is out of range&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = node_store_.<span class="built_in">find</span>(frame_id);</span><br><span class="line">  <span class="keyword">if</span> (it == node_store_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> &amp;node = it-&gt;second;</span><br><span class="line">  <span class="keyword">if</span> (node.is_evictable_) &#123;</span><br><span class="line">    curr_size_--;</span><br><span class="line">  &#125;</span><br><span class="line">  node_store_.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>check legal</li>
<li>find the actual element</li>
<li>update the hash map</li>
</ol>
<h3 id="Disk-Scheduler-and-Manager"><a href="#Disk-Scheduler-and-Manager" class="headerlink" title="Disk Scheduler and Manager"></a>Disk Scheduler and Manager</h3><blockquote>
<p>The disk scheduler can be used by other components (in this case, your <code>BufferPoolManager</code> in Task #3) to queue disk requests, represented by a <code>DiskRequest</code> struct (already defined in <code>src/include/storage/disk/disk_scheduler.h</code>). The disk scheduler will maintain a background worker thread which is responsible for processing scheduled requests.</p>
</blockquote>
<blockquote>
<p>The disk scheduler will utilize a shared queue to schedule and process the DiskRequests. One thread will add a request to the queue, and the disk schedulerâ€™s background worker will process the queued requests. We have provided a <code>Channel</code> class in <code>src/include/common/channel.h</code> to facilitate the safe sharing of data between threads, but feel free to use your own implementation if you find it necessary.</p>
</blockquote>
<p>This is actually quite easy, and I think the main challenge is to familarize yourself with the Promise and Future in C++ 17. (Cool stuff, but reminds me deeply of the trauma I had with JavaScriptâ€™s Promise and Future). </p>
<p>The main challenge is to implement a thread safe channel construct, which has been provided already. The rest is very straightforward, as long as you are familiar with the move semantics. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DiskScheduler::Schedule</span><span class="params">(DiskRequest r)</span> </span>&#123; request_queue_.<span class="built_in">Put</span>(std::<span class="built_in">make_optional</span>(std::<span class="built_in">move</span>(r))); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DiskScheduler::StartWorkerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> request = request_queue_.<span class="built_in">Get</span>();</span><br><span class="line">    <span class="keyword">if</span> (!request.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (request-&gt;is_write_) &#123;</span><br><span class="line">      disk_manager_-&gt;<span class="built_in">WritePage</span>(request-&gt;page_id_, request-&gt;data_);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      disk_manager_-&gt;<span class="built_in">ReadPage</span>(request-&gt;page_id_, request-&gt;data_);</span><br><span class="line">    &#125;</span><br><span class="line">    request-&gt;callback_.<span class="built_in">set_value</span>(<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DiskRequest</span> &#123;</span><br><span class="line">  <span class="comment">// some other code</span></span><br><span class="line">  std::promise&lt;<span class="type">bool</span>&gt; callback_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Since the DiskRequest contains a Promise object, it cannot be copied, but only moved to the shared queue. After the thread has finished its job, it sets the flag in the callback Promise. </p>
<h3 id="Buffer-Pool-Manager"><a href="#Buffer-Pool-Manager" class="headerlink" title="Buffer Pool Manager"></a>Buffer Pool Manager</h3><p>This is the main challenge. It is intricate, and delicate, and very hard to debug. It took me several hours to finally get it right (and I an still not sure which part that I touched made things come to the right track). </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::NewPage</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> -&gt; Page * </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// get the page directly from the free list</span></span><br><span class="line">    frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (replacer_-&gt;<span class="built_in">Evict</span>(&amp;frame_id)) &#123;</span><br><span class="line">    Page &amp;page = pages_[frame_id];</span><br><span class="line">    <span class="keyword">if</span> (page.<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">      <span class="built_in">FlushPage</span>(page.<span class="built_in">GetPageId</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_.<span class="built_in">erase</span>(page.<span class="built_in">GetPageId</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *page_id = <span class="built_in">AllocatePage</span>();</span><br><span class="line"></span><br><span class="line">  Page &amp;page = pages_[frame_id];</span><br><span class="line">  page.<span class="built_in">ResetMemory</span>();</span><br><span class="line">  page.page_id_ = *page_id;</span><br><span class="line">  page.is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  page.pin_count_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  page_table_[*page_id] = frame_id;</span><br><span class="line"></span><br><span class="line">  replacer_-&gt;<span class="built_in">Remove</span>(frame_id);</span><br><span class="line">  replacer_-&gt;<span class="built_in">RecordAccess</span>(frame_id, AccessType::Unknown);</span><br><span class="line">  replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> &amp;page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This function allocates a new page in the buffer pool manager. The logic is that:</p>
<ol>
<li>If there is a page in the free list, allocate directly. </li>
<li>otherwise we need to evict a oage from the LRU replacer (Do remember to detach the original evicted page, delete it from page table, and remove it from the replacer, otherwise the LRU-K policy will not be functioning correctly)</li>
<li>donâ€™t forget that if the page is dirty, we need to flush it to disk. </li>
<li>initialize the new page with a pin count, a dirty flag, a new page id(unique to this sepcific buffer pool manager), and touch the page with the recordAccess.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FetchPage</span><span class="params">(<span class="type">page_id_t</span> page_id, [[maybe_unused]] AccessType access_type)</span> -&gt; Page * </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> page_table_it = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (page_table_it != page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// page is in the buffer pool</span></span><br><span class="line">    <span class="comment">// printf(&quot;Fetching page first phase, page found in buffer pool\n&quot;);</span></span><br><span class="line">    <span class="type">frame_id_t</span> frame_id = page_table_it-&gt;second;</span><br><span class="line">    Page &amp;page = pages_[frame_id];</span><br><span class="line">    page.pin_count_++;</span><br><span class="line">    replacer_-&gt;<span class="built_in">RecordAccess</span>(frame_id, access_type);</span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> &amp;page;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Fetching page first phase, page not found in buffer pool\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// page is not in the buffer pool</span></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// get the page directly from the free list</span></span><br><span class="line">    frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get the page from the free list\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (replacer_-&gt;<span class="built_in">Evict</span>(&amp;frame_id)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;evict the page from the replacer, frame id is %d\n&quot;</span>, frame_id);</span><br><span class="line">    Page &amp;page = pages_[frame_id];</span><br><span class="line">    <span class="keyword">if</span> (page.<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;the page evicted is dirty\n&quot;</span>);</span><br><span class="line">      <span class="built_in">FlushPage</span>(page.<span class="built_in">GetPageId</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    page_table_.<span class="built_in">erase</span>(page.<span class="built_in">GetPageId</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;the page is getting del\n&quot;);</span></span><br><span class="line">    <span class="comment">// DeletePage(page.GetPageId());</span></span><br><span class="line">    <span class="comment">// printf(&quot;deletion done\n&quot;);</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reset the metadata of the new page</span></span><br><span class="line">  Page &amp;page = pages_[frame_id];</span><br><span class="line">  page.<span class="built_in">ResetMemory</span>();</span><br><span class="line">  page.page_id_ = page_id;</span><br><span class="line">  page.pin_count_ = <span class="number">1</span>;  <span class="comment">// Pin the new page.</span></span><br><span class="line">  page.is_dirty_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// schedule a read request</span></span><br><span class="line">  DiskRequest read_request;</span><br><span class="line">  read_request.is_write_ = <span class="literal">false</span>;</span><br><span class="line">  read_request.data_ = page.data_;</span><br><span class="line">  read_request.page_id_ = page_id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create the Promise and get its future</span></span><br><span class="line">  <span class="keyword">auto</span> promise = disk_scheduler_-&gt;<span class="built_in">CreatePromise</span>();</span><br><span class="line">  <span class="keyword">auto</span> future = promise.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the Promise to the callback</span></span><br><span class="line">  read_request.callback_ = std::<span class="built_in">move</span>(promise);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// schedule the read request</span></span><br><span class="line">  disk_scheduler_-&gt;<span class="built_in">Schedule</span>(std::<span class="built_in">move</span>(read_request));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait for the read request to finish</span></span><br><span class="line">  future.<span class="built_in">wait</span>();</span><br><span class="line"></span><br><span class="line">  page_table_[page_id] = frame_id;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Fetching page last phase\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  replacer_-&gt;<span class="built_in">Remove</span>(frame_id);</span><br><span class="line">  replacer_-&gt;<span class="built_in">RecordAccess</span>(frame_id, access_type);</span><br><span class="line">  replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">return</span> &amp;page;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FetchPage implementation shares exactly the same logic as the NewPage, the only difference being that after fetching a free page, we need to also fetch the page content from the disk, using the Promise and future. Here we only care about correctness, so wait until IO is finished. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::UnpinPage</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty, [[maybe_unused]] AccessType access_type)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (it == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  frame_id = it-&gt;second;</span><br><span class="line"></span><br><span class="line">  Page &amp;page = pages_[frame_id];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (page.pin_count_ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  page.pin_count_--;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (page.pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">    replacer_-&gt;<span class="built_in">SetEvictable</span>(frame_id, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_dirty) &#123;</span><br><span class="line">    page.is_dirty_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// FlushPage(page_id);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The thing that I got wrong with this unpin funciton initially is that here we are not writing to disk, we are only unpinning. To achieve good performance, we want to delay IO as much as possible, instead of writing to the disk everyting we unpins. </p>
<p>Flush page is easy, just write to disk, regardless of the dirty bit. The dirty bit will be checked by upper layers. But we do need to clear the dirty flag after writing to disk. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::FlushPage</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="comment">// std::lock_guard&lt;std::mutex&gt; lock(latch_);</span></span><br><span class="line">  <span class="keyword">auto</span> it = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (it == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = it-&gt;second;</span><br><span class="line">  Page &amp;page = pages_[frame_id];</span><br><span class="line"></span><br><span class="line">  DiskRequest write_request;</span><br><span class="line">  write_request.is_write_ = <span class="literal">true</span>;</span><br><span class="line">  write_request.data_ = page.<span class="built_in">GetData</span>();</span><br><span class="line">  write_request.page_id_ = page.<span class="built_in">GetPageId</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// create the Promise and get its future</span></span><br><span class="line">  <span class="keyword">auto</span> promise = disk_scheduler_-&gt;<span class="built_in">CreatePromise</span>();</span><br><span class="line">  <span class="keyword">auto</span> future = promise.<span class="built_in">get_future</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the Promise to the callback</span></span><br><span class="line">  write_request.callback_ = std::<span class="built_in">move</span>(promise);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// schedule the write request</span></span><br><span class="line">  disk_scheduler_-&gt;<span class="built_in">Schedule</span>(std::<span class="built_in">move</span>(write_request));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait for the write request to finish</span></span><br><span class="line">  future.<span class="built_in">wait</span>();</span><br><span class="line">  page.is_dirty_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// page_table_.erase(it);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DeletePage"><a href="#DeletePage" class="headerlink" title="DeletePage"></a>DeletePage</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BufferPoolManager::DeletePage</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> -&gt; <span class="type">bool</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> it = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (it == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = it-&gt;second;</span><br><span class="line">  <span class="comment">// printf(&quot;deletePage, the page id is %d, and the frame id is %d\n&quot;, page_id, frame_id);</span></span><br><span class="line">  Page &amp;page = pages_[frame_id];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (page.pin_count_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (page.<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">    <span class="built_in">FlushPage</span>(page_id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  page.<span class="built_in">ResetMemory</span>();</span><br><span class="line">  page.page_id_ = INVALID_PAGE_ID;</span><br><span class="line">  page.pin_count_ = <span class="number">0</span>;</span><br><span class="line">  page.is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  page_table_.<span class="built_in">erase</span>(it);</span><br><span class="line">  <span class="comment">// replacer_-&gt;SetEvictable(frame_id, true);</span></span><br><span class="line">  replacer_-&gt;<span class="built_in">Remove</span>(frame_id);</span><br><span class="line">  free_list_.<span class="built_in">push_back</span>(frame_id);</span><br><span class="line">  <span class="built_in">DeallocatePage</span>(page_id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DeletePage is also easy, just remember to </p>
<ol>
<li>not delete if the page is still pinned. </li>
<li>flush the page if it is dirty. </li>
<li>clear all page table and LRU replacer entry. </li>
<li>add the page back to the freelist.</li>
</ol>
<h3 id="Ending-Remark"><a href="#Ending-Remark" class="headerlink" title="Ending Remark"></a>Ending Remark</h3><p>It looks easy, but the logic can be complicated, a little. And it is very hard to debug.  Nevertheless, implementing a buffer pool manager is important for me to understand how a disk backed dbms really worked internally. A good lesson to learn, I would say. </p>
</div><div class="article-licensing box"><div class="licensing-title"><p>[Database] Bustub Buffer Pool Manager Implementation</p><p><a href="http://peteryaonyu.github.io/2023/12/18/Database-Bustub-Buffer-Pool-Manager-Implementation/">http://peteryaonyu.github.io/2023/12/18/Database-Bustub-Buffer-Pool-Manager-Implementation/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Yuncheng Yao</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2023-12-18</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-01-08</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/01/08/Implementing-a-MapReduce-Framework-with-Golang-from-scratch/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Implementing a MapReduce Framework with Golang RPC from scratch</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/07/10/cmu15-213-attack-lab/"><span class="level-item">CMU15-213 Attack Lab</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/images/avatar.jpg" alt="Yao Yuncheng (Peter)"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Yao Yuncheng (Peter)</p><p class="is-size-6 is-block">yy4108@nyu.edu</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shanghai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/PeterYaoNYU" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/PeterYaoNYU"><i class="fab fa-github"></i></a></div></div></div><!--!--><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-04-08T02:25:07.000Z">2024-04-07</time></p><p class="title"><a href="/2024/04/07/Compiler-Construction-in-Ocaml-Hindley-Milner-Type-Inference-System-Implementation/">[Compiler Construction in Ocaml] Hindley-Milner Type Inference System Implementation</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-14T03:36:41.000Z">2024-01-13</time></p><p class="title"><a href="/2024/01/13/Database-Implementation-of-an-Entendible-Hash-Index/">[Database] Implementation of an Entendible Hash Index</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-12T09:12:17.000Z">2024-01-12</time></p><p class="title"><a href="/2024/01/12/Consensus-Raft-from-Scratch-Leader-Election/">[Consensus] Raft from Scratch: Leader Election</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-09T04:21:48.000Z">2024-01-08</time></p><p class="title"><a href="/2024/01/08/Implementing-a-MapReduce-Framework-with-Golang-from-scratch/">Implementing a MapReduce Framework with Golang RPC from scratch</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-19T00:18:38.000Z">2023-12-18</time></p><p class="title"><a href="/2023/12/18/Database-Bustub-Buffer-Pool-Manager-Implementation/">[Database] Bustub Buffer Pool Manager Implementation</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Compiler/"><span class="tag">Compiler</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Database-Systems/"><span class="tag">Database Systems</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Distribute-Systems/"><span class="tag">Distribute Systems</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-Systems/"><span class="tag">Operating Systems</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Yao Yuncheng(Peter)</a><p class="is-size-7"><span>&copy; 2024 Yuncheng Yao</span>Â Â Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>Â &amp;Â <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">Â© 2023</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/PeterYaoNYU"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">Ã—</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>